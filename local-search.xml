<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetbook算法笔记（六）前缀和与差分专题</title>
    <link href="/2023/07/10/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86%E4%B8%93%E9%A2%98/"/>
    <url>/2023/07/10/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="前缀和与差分专题"><a href="#前缀和与差分专题" class="headerlink" title="前缀和与差分专题"></a>前缀和与差分专题</h2><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><h4 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h4><p>前缀和是算法题中一个重要的技巧，经常作为一种优化方式出现在其他算法的一些子环节中。</p><p><strong>前缀和就是从位置1到位置i这个区间内的所有的数字之和。进而我们能用o1的时间复杂度得到某块区间的总和</strong></p><p>考虑如下问题</p><blockquote><p>给定一个长度为n的序列a1,a2,……,an，有m次询问，每次询问给定l和r，求a序列中l到r下标(包括l和r)的元素之和，形式化地，求$\sum_\limits{i=left}^{right}a_i$</p></blockquote><p>用for循环遍历从l到r是直接的。但是时间复杂度是$O(mn)$,当mn规模增大到10^5时会超时。所以我们需要优化。</p><p>在一些数学题中，我们经常会用到一个技巧：加上一个数，再减去一个数，结果不变。</p><p>所以，有$f(i)=\sum\limits_{k=1}^{i}a_k$时，$\sum_\limits{i=left}^{right} a_i=f(right)-f(left-1)$</p><p>而$f(i)=\sum\limits_{k=1}^{i}a_k=a_i+\sum\limits_{k=1}^{i-1}a_k=a_i+f(i-1)$​</p><p>即为，前缀和数组s[i]=a[1]+a[2]+a[3]+…+a[i];</p><p>s[L]=a[1]+a[2]+…+a[L];</p><p>s[R]=a[1]+a[2]+…+a[L]+…a[R];</p><p>s[R]-s[L-1]就是闭区间[L,R]内元素之和。</p><p>所以有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-type">int</span> N;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)&#123;<br>sum[i]=sum[i<span class="hljs-number">-1</span>]+a[i];<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br><span class="hljs-keyword">return</span> sum[right]-sum[left<span class="hljs-number">-1</span>];<br>&#125;<br><br></code></pre></td></tr></table></figure><p>总体时间复杂度是O(n+m),我们把f(i)（sum[i]）称为前缀和函数（数组）</p><h4 id="🚩二维前缀和"><a href="#🚩二维前缀和" class="headerlink" title="🚩二维前缀和"></a>🚩二维前缀和</h4><p>在一维前缀和之上，求一个矩阵内子矩阵的和，可以使用<strong>二维前缀和</strong></p><p><img src="/2023/07/10/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86%E4%B8%93%E9%A2%98/image-20240325110039609.png" alt="image-20240325110039609"></p><h5 id="前缀和的计算"><a href="#前缀和的计算" class="headerlink" title="前缀和的计算"></a>前缀和的计算</h5><p>对于数组<code>a[i][j]</code>的前缀和数组<code>sum[i][j]</code>，有<code>sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j]</code></p><p>其原理见图</p><p><img src="/2023/07/10/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86%E4%B8%93%E9%A2%98/image-20240325111105465.png" alt="image-20240325111105465"></p><p>这样我们得到了从数组起点始到<code>sum[i][j]</code>的前缀和</p><blockquote><p>[!tip]</p><p>因为对<code>sum[i][j]</code>的计算涉及到<code>sum[i-1][j-1]</code>等等之前的数组，所以一般sum数组从下标1开始，初始化为0.</p></blockquote><h5 id="任意子矩阵和的计算"><a href="#任意子矩阵和的计算" class="headerlink" title="任意子矩阵和的计算"></a>任意子矩阵和的计算</h5><p>我们预处理得到所有前缀和后，常见的任务就是求大矩阵中<strong>任意子矩阵和</strong>(即从任意起始点到<code>sum[i][j]</code>)，比如CCF22-2.邻域均值题。</p><p>我们定义(x1,y1)为待求子矩阵的左上角（起始点），(x2,y2)为待求子矩阵的右下角（终点）</p><p>我们发现待求子矩阵的和<code>subsum=sum[x2][y2]-sum[x1-1][y2]-sum[x2][y1-1]+sum[x1-1][y1-1]</code></p><blockquote><p>[!warning]</p><p>从图上我们只能看出<code>sum[x2][y2]-sum[x1][y2]-sum[x2][y1]+sum[x1][y1]</code>,但画图是没有考虑边界的，我们需要考虑边界。</p><p>所以相关红色（减去）部分需要相对于绿色（待求）部分下标退一步，即</p><p><code>sum[x2][y2]-sum[x1-1][y2]-sum[x2][y1-1]+sum[x1-1][y1-1]</code></p><p>时间复杂度<code>O（1）</code></p></blockquote><p><img src="/2023/07/10/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86%E4%B8%93%E9%A2%98/image-20240325114033203.png" alt="image-20240325114033203"></p><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>我们知道，前缀和是把当下的数字加上之前的和，不断累积，并且时间复杂度在O(1)之内的算法。那么如果希望一个序列某个或全部范围的元素都加上（减去）某个数，并且仍然希望时间复杂度是O(1)（这种问题O(n)的时间复杂度解决是简单的）。我们就要用差分的方法。</p><p>差分可以说是前缀和的逆运算。</p><p>我们使得下标为1时的差分数组<code>diff[1]=a[i]</code>，之后<code>diff[i]=a[i]-a[i-1]</code>。便可得到差分数组，将差分数组求前缀和，就能得到原数组。</p><p>如果我们提前将差分数组的<code>diff[1]=a[i]+c</code>,那么我们将其求前缀和后，就能得到原数组整体加c后的结果。</p><p>如果我们希望对数组中的[l,r]区间整体加c，那么我们需要单独使得<code>diff[l]=a[l]-a[l-1]+c</code>，<code>diff[r+1]=a[r+1]-(a[r]+c)</code>，之后再求前缀和</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetbook算法笔记（拾遗1）数学与位运算</title>
    <link href="/2023/06/01/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E6%8B%BE%E9%81%971%EF%BC%89%E6%95%B0%E5%AD%A6%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2023/06/01/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E6%8B%BE%E9%81%971%EF%BC%89%E6%95%B0%E5%AD%A6%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="数学与位运算专题"><a href="#数学与位运算专题" class="headerlink" title="数学与位运算专题"></a>数学与位运算专题</h2><h3 id="常用数论知识"><a href="#常用数论知识" class="headerlink" title="常用数论知识"></a>常用数论知识</h3><h4 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h4><h5 id="判定质数"><a href="#判定质数" class="headerlink" title="判定质数"></a>判定质数</h5><p>我们知道素数只能被1和他自身x整除，而试除法就是利用这一特性，从除2到除x-1，只要可以整除，那么就不是素数，这种方法称为<strong>试除法</strong>。但是这样时间复杂度较高。</p><p>我们注意到如果一个数不是素数，那么必然存在一个因子i，使得i*x/i=x，因子都是成对出现的。那么我们并不用循环到x-1，循环到x/i即可。时间复杂度为根号n。</p><p>试除法判定质数代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h5><p><strong>试除法</strong>同样适用于分解质因数。</p><p>如前所述，如果能整除我们得到一个因数。那我们从小到大枚举所有质因数，再求出因数的次数即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//i 质因数 s 质因数的次数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i, s ++ ;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">/*input </span><br><span class="hljs-comment">54</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/*output</span><br><span class="hljs-comment">2 1</span><br><span class="hljs-comment">3 3</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="筛选质数"><a href="#筛选质数" class="headerlink" title="筛选质数"></a>筛选质数</h5><p>朴素筛法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (st[i]) <span class="hljs-keyword">continue</span>;<br>        primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + i; j &lt;= n; j += i)<br>            st[j] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>线性筛法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h4><h4 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h4><h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h4 id="向量的内积（点积）和外积（叉积）"><a href="#向量的内积（点积）和外积（叉积）" class="headerlink" title="向量的内积（点积）和外积（叉积）"></a>向量的内积（点积）和外积（叉积）</h4><p>矩阵的运算是基于向量间的运算的。这节介绍向量间的简单运算。</p><p>由于历史原因，数学、物理领域对inner product和outer product 有着许多翻译。</p><p>在物理学科，一般翻译成为<strong>标积（inner product）</strong>和<strong>矢积（outer product）</strong>，它们和高中数学的<strong>数量积（inner product）</strong>、<strong>向量积（outer product）</strong>都是意译。</p><p>在数学学科，通常也可以翻译成<strong>内积（inner product）</strong>和<strong>外积（outer product）</strong>，是两个名词的直译。<strong>点乘</strong>和<strong>叉乘</strong>是根据运算符号得来的俗称，这种俗称也很常见。</p><h5 id="内积"><a href="#内积" class="headerlink" title="内积"></a>内积</h5><p>对于向量来说，已知有两个向量a 、b ，其夹角为θ，那么内积（数量积）为</p><script type="math/tex; mode=display">a·b=|a||b|cosθ</script><p>内积的几何意义为：内积 $a·b$ 等于$a$的模与$b$在$a$方向上的投影长度的<strong>乘积</strong></p><p>我们发现，这种运算得到的结果是一个<strong>标量</strong>，并不属于向量的线性运算</p><h5 id="外积"><a href="#外积" class="headerlink" title="外积"></a>外积</h5><p>对于向量来说，外积是<strong>三维向量</strong>特有的运算。</p><p>已知有两个向量a 、b ，其夹角为θ，那么我们定义它的外积（向量积）为</p><ul><li>对于$a×b$，它的模长为$a×b=|a||b|sinθ$​</li><li>对于$a×b$​，它的方向与a b都垂直，且a、b、a×b 符合右手法则</li></ul><p>换言之</p><p><img src="/2023/06/01/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E6%8B%BE%E9%81%971%EF%BC%89%E6%95%B0%E5%AD%A6%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97/image-20240326164829641.png" alt="image-20240326164829641"></p><h4 id="矩阵相关概念"><a href="#矩阵相关概念" class="headerlink" title="矩阵相关概念"></a>矩阵相关概念</h4><h5 id="同型矩阵"><a href="#同型矩阵" class="headerlink" title="同型矩阵"></a>同型矩阵</h5><p>两个矩阵，行数与列数对应相同，称为同型矩阵。</p><h5 id="方阵"><a href="#方阵" class="headerlink" title="方阵"></a>方阵</h5><p>行数等于列数的矩阵称为方阵。方阵是一种特殊的矩阵。对于「n 阶矩阵」的习惯表述，实际上讲的是 n阶方阵。阶数相同的方阵为同型矩阵。</p><h5 id="主对角线"><a href="#主对角线" class="headerlink" title="主对角线"></a>主对角线</h5><p>方阵中行数等于列数的元素构成主对角线。</p><h5 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h5><p>如果方阵的元素关于主对角线对称，即对于任意i和j，i行j列的元素和j行i列的元素相等，那么该方阵称为对称矩阵。</p><h4 id="矩阵相关运算"><a href="#矩阵相关运算" class="headerlink" title="矩阵相关运算"></a>矩阵相关运算</h4><h5 id="矩阵的线性运算"><a href="#矩阵的线性运算" class="headerlink" title="矩阵的线性运算"></a>矩阵的线性运算</h5><h6 id="加减"><a href="#加减" class="headerlink" title="加减"></a>加减</h6><p>同型矩阵可以进行加减运算。</p><p>矩阵的加减为<strong>矩阵A的每个元素和矩阵B的<em>对应位置</em>元素相加减</strong>。</p><p><img src="/2023/06/01/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E6%8B%BE%E9%81%971%EF%BC%89%E6%95%B0%E5%AD%A6%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97/image-20240326162936655.png" alt="image-20240326162936655"></p><h6 id="数乘"><a href="#数乘" class="headerlink" title="数乘"></a>数乘</h6><p>数乘与向量的数乘相似，<strong>矩阵中<em>每个</em>元素乘以常数</strong></p><p><img src="/2023/06/01/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E6%8B%BE%E9%81%971%EF%BC%89%E6%95%B0%E5%AD%A6%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97/image-20240326163132697.png" alt="image-20240326163132697"></p><h5 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h5><p>矩阵转置就是将矩阵的行与列互换，在矩阵A的右上角用T符号标记，即转置矩阵$A^T$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">transpose</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix) &#123;<br>    <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">transposed</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            transposed[j][i] = matrix[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> transposed;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h5><p>由内积外积的知识我们知道，矩阵的乘法也是能求出两种积的。</p><p>而<strong>通常意义上的矩阵乘法指的是矩阵的外积（叉乘）</strong>，它是向量内积的推广。</p><p>矩阵相乘只有在<strong>第一个矩阵的列数和第二个矩阵的行数相同</strong>时才有意义。</p><p>如果有A×B=C，外积矩阵C中的第i行第j列的元素，就是<strong>A矩阵第i行第k个元素（列）</strong>和<strong>B矩阵第j列第k个元素（行）</strong>之和，即<strong>左行右列</strong>。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//矩阵A n行m列</span><br><span class="hljs-comment">//矩阵B m行p列</span><br><span class="hljs-comment">//外积矩阵C n行p列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; p; j++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>; k &lt; m; k++) &#123;<br>            c[i][j]+=a[i][k]*b[k][j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!note]</p><p>矩阵相乘符合结合律 (A×B)×C = A×(B×C)，对数乘的结合性 k(AB)=(kA)B=A(kB）</p><p>左分配律(A+B)C=AC+BC 右分配律C(A+B)=CA+CB </p><p>但是交换律极为严苛，可以看作一般不满足交换律</p><p>因为不满足交换律，矩阵连乘 A×B×C×D×E<strong>必须从右向左乘</strong>，A×B×C×D×E=A×(B×(C×(D×E)))</p></blockquote><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>高斯消元法是解线性方程组的经典算法，它能在$O(n^3)$的时间复杂度内，求有n个方程n个未知数的多元线性方程组。</p><p>将方程组中一个方程的未知数用含有另一未知数的代数式表示，并将其带入到另一方程中，这就消去了一未知数，即为消元法。</p><p>高斯对消元法进行分析，扩展出如下结论</p><ol><li>消元法中，参与计算和改变的是方程组变量的系数。</li><li>变量本身没有改变</li><li>可以用系数的为止表示变量，从而省略变量</li><li>在计算中省略变量，解不变</li></ol><p>高斯消元，先将系数和解抽离出<strong>增广矩阵</strong>，使用<strong>初等行列变换</strong>，变为（上三角）<strong>行最简形矩阵</strong>。</p><blockquote><p>[!tip]</p><p><strong>增广 矩阵 </strong>（又称扩增矩阵）就是在 <strong>系数矩阵 </strong>的<strong>右边</strong>添上一列，这一列是 线性方程组 的 <strong>等号 右边的值</strong>也即是<strong>方程解</strong></p><p><strong>行列式初等变换</strong>包括这三种操作：</p><ol><li>把某一行乘以一个非零的数</li><li>交换某2行</li><li>把某行的若干倍加到另一行</li></ol><p>非零行的<strong>第一个非零元素全是1</strong>，且非零行的第一个元素1所在列的其余元素全为零，就称该矩阵为<strong>行最简形矩阵</strong></p></blockquote><p>即把方程组变为如下形式</p><script type="math/tex; mode=display">\left\{    \begin{eqnarray}{}    a_{1,1}x_1+a_{1,2}x_2+...+a_{1,n}x_n&=&b_1\\    a_{2,2}x_2+...+a_{2,n}x_n&=&b_2\\    ...&&...\\    a_{n-1,n-1}x_{n}&=&b_{n-1}\\    x_n&=&b_n    \end{eqnarray}\right.</script><p>这样，由下向上代入可求得所有未知数。考虑解情况</p><p>当完美阶梯型（满秩）有唯一解。</p><p>对于不完美阶梯型有</p><ol><li>出现左边没有未知数，右边非0情况，无解</li><li>出现0=0时，有无穷多组解</li></ol><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>枚举每一列<code>c</code>，小于c的行固定<ol><li>找到该列元素中绝对值最大的那一行</li><li>将该行换到最上面那一行，即c+1行</li><li>将该行第一个数变成<code>1</code>，即把该行所有数除以第一个数。</li><li>将c+1行下面所有行的当前列，通过行加减法，消成<code>0</code></li><li>固定该行，亦即小于c的行不参与下一轮计算。</li></ol></li><li>重复到结束</li></ol><h4 id="高斯消元法解线性方程组问题"><a href="#高斯消元法解线性方程组问题" class="headerlink" title="高斯消元法解线性方程组问题"></a>高斯消元法解线性方程组问题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-comment">// 浮点0</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps= <span class="hljs-number">1e-6</span>;<br><br><span class="hljs-type">int</span> n; <span class="hljs-comment">//n行方程</span><br><span class="hljs-type">double</span> a[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gauss</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> col,row;<br><span class="hljs-keyword">for</span>(col=<span class="hljs-number">0</span>,row=<span class="hljs-number">0</span>;col&lt;n;col++)&#123;<br><span class="hljs-type">int</span> t=row;<br><span class="hljs-comment">//元素绝对值最大的那一行</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=row; i&lt;n;i++)<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[i][col])&gt;<span class="hljs-built_in">fabs</span>(a[t][col]))<br>t=i;<br>        <span class="hljs-comment">//本就是0，忽略</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[t][col])&lt;eps) <span class="hljs-keyword">continue</span>;<br>        <br>        <span class="hljs-comment">//交换 除成1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=col;i&lt;=n  ;i++) <span class="hljs-built_in">swap</span>(a[t][i],a[row][i]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n  ;i&gt;=col;i--) a[row][i]/=a[row][col];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=row + <span class="hljs-number">1</span>; i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[i][col])&gt;eps)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=n;j&gt;=col;j--)<br>        a[i][j]-=a[row][j]*a[i][col];<br>        &#125;<br>        row++;<br>&#125;<br><span class="hljs-keyword">if</span>(row&lt;n)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=row;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[i][n])&gt;eps)<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-comment">//无解</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)<br>        a[i][n]-=a[i][j]*a[j][n];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n+<span class="hljs-number">1</span>;j++)&#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> t=<span class="hljs-built_in">gauss</span>();<br>    <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>,a[i][n]);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t==<span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Infinite group solutions&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No solution&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><h5 id="加法原理"><a href="#加法原理" class="headerlink" title="加法原理"></a>加法原理</h5><h5 id="乘法原理"><a href="#乘法原理" class="headerlink" title="乘法原理"></a>乘法原理</h5><p>如果一个任务包含$n$个<strong>步骤</strong>，其中第$i$个步骤有$x_i$种不同的做法，且这些做法彼此独立，则完成这个任务共有$x_1 × x_2 × x_3 ×…×  x_n$种不同的做法。</p><h5 id="排列数"><a href="#排列数" class="headerlink" title="排列数"></a>排列数</h5><p>从$n$个不同元素中依次取$m$个元素（$m≤n$）产生的不同<strong>排列</strong>的数量为</p><script type="math/tex; mode=display">P_n^m=\frac{n!}{(n-m)!}</script><h5 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h5><p>从$n$个不同的元素中任取$m$个元素（$m≤n$）产生的不同<strong>组合</strong>的数量为</p><script type="math/tex; mode=display">C_n^m=\frac{P_n^m}{m!}=\frac{n!}{m!(n-m)!}=\frac{n × (n-1) × ...×(n-m+1)}{1×2×...×m}</script><h4 id="求组合数问题"><a href="#求组合数问题" class="headerlink" title="求组合数问题"></a>求组合数问题</h4><h5 id="递推法"><a href="#递推法" class="headerlink" title="递推法"></a>递推法</h5><p>考虑如下问题</p><blockquote><p>从a个苹果中选出b个，方案数是$C_a^b$，所有的方案能分成两种情况，一是包含某个苹果的选法$C_{a-1}^{b-1}$，因为除了这个苹果我们还还有a-1个苹果；另一个是不包含某个苹果的选法$C_{a-1}^{b}$。这两类能不重不漏地覆盖$C_a^b$</p></blockquote><p>所以我们发现有递推式</p><script type="math/tex; mode=display">C_a^b=C_{a-1}^b+C_{a-1}^{b-1}</script><p>这样我们能够<strong>递推</strong>求组合数，降低时间复杂度。</p><p>对于10万组、$1&lt;=b&lt;=a&lt;=2000$的数据，递推是高效的。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//组合数组初始化</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> N=<span class="hljs-number">2010</span>,<span class="hljs-keyword">mod</span> = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-keyword">void</span> init()&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;j++)&#123;<br><span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>) c[i][j]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> (c[i][j]=c[i<span class="hljs-number">-1</span>][j]+c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%<span class="hljs-keyword">mod</span>; <span class="hljs-comment">//大数取模</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="预处理法"><a href="#预处理法" class="headerlink" title="预处理法"></a>预处理法</h5><p>对于10万组、$1&lt;=b&lt;=a&lt;=10^5$的数据，我们发现使用数组并不方便。此时我们预处理公式$C_n^m=\frac{n!}{m!(n-m)!}$中的阶乘。</p><p>我们可以使<code>fact[i]=i! mod 1e9+7</code> ,它的逆元<code>infact[i] = (i!)^-1 mod 1e9+7</code></p><p>那么$C_a^b$就可以用阶乘和阶乘的逆元表示,<code>c[a][b]=fact[a] * infact[a-b] * infact[b]</code></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs excel">typedef long long LL;<br>const <span class="hljs-built_in">int</span> <span class="hljs-built_in">N</span> =<span class="hljs-number">100010</span>, <span class="hljs-built_in">mod</span>=<span class="hljs-number">1</span>e9+<span class="hljs-number">7</span>;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">fact</span>[<span class="hljs-built_in">N</span>],infact[<span class="hljs-built_in">N</span>];<br>//快速幂求逆元<br>//a的k次方模p的值<br><span class="hljs-built_in">int</span> qmi(<span class="hljs-built_in">int</span> a ,<span class="hljs-built_in">int</span> k, <span class="hljs-built_in">int</span> p)&#123;<br><span class="hljs-built_in">int</span> res =<span class="hljs-number">1</span>;<br>while(k)&#123;<br><span class="hljs-built_in">if</span>(k&amp;<span class="hljs-number">1</span>) res=(LL)res *a %p;<br>a=(LL)a * a % p ;<br>k&gt;&gt;=<span class="hljs-number">1</span>;<br>&#125;<br>return res;<br>&#125;<br><span class="hljs-built_in">int</span> main()&#123;<br><span class="hljs-built_in">fact</span>[<span class="hljs-number">0</span>]=infact[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">N</span>;i++)&#123;<br><span class="hljs-built_in">fact</span>[i]=(LL)<span class="hljs-built_in">fact</span>[i-<span class="hljs-number">1</span>]*i%<span class="hljs-built_in">mod</span>;<br>infact[i]=(LL)infact[i-<span class="hljs-number">1</span>]*qmi(i,<span class="hljs-built_in">mod</span>-<span class="hljs-number">2</span>,<span class="hljs-built_in">mod</span>)%<span class="hljs-built_in">mod</span>;<br>&#125;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>;<br>scanf(<span class="hljs-string">&quot;%d&quot;</span>,&amp;<span class="hljs-built_in">n</span>);<br>while(<span class="hljs-built_in">n</span>--)&#123;<br><span class="hljs-built_in">int</span> a,b;<br>scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<br>printf(<span class="hljs-string">&quot;%d\n&quot;</span>,(LL)<span class="hljs-built_in">fact</span>[a]*infact[b]%<span class="hljs-built_in">mod</span>*infact[a-b]%<span class="hljs-built_in">mod</span>);<br>&#125;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Lucas定理法"><a href="#Lucas定理法" class="headerlink" title="Lucas定理法"></a>Lucas定理法</h5><p>当有20组、$1&lt;=b&lt;=a&lt;=10^{18}$、$质数1&lt;=p&lt;=10^5$数据，求$C_a^b\ mod\ p$时</p><p>递推、预处理都不适用，此时我们使用卢卡斯（Lucas）定理法。</p><p>Lucas定理指出</p><script type="math/tex; mode=display">C_a^b \equiv C_{a\ mod\ p}^{b\ mod\ p}×C_{a/p}^{b/p}(mod\ p)</script><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">typedef long long LL;<br><span class="hljs-built_in">int</span> p;<br><span class="hljs-comment">//快速幂</span><br><span class="hljs-built_in">int</span> qmi(<span class="hljs-built_in">int</span> a,<span class="hljs-built_in">int</span> k)&#123;<br><span class="hljs-built_in">int</span> res=<span class="hljs-number">1</span>; <br><span class="hljs-keyword">while</span>(k)&#123;<br><span class="hljs-keyword">if</span>(k&amp;<span class="hljs-number">1</span>) res=(LL)res *a %p;<br>a=(LL)a*a%p;<br>k&gt;&gt;=<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//从定义出发</span><br><span class="hljs-built_in">int</span> <span class="hljs-constructor">C(<span class="hljs-params">int</span> <span class="hljs-params">a</span>,<span class="hljs-params">int</span> <span class="hljs-params">b</span>)</span>&#123;<br><span class="hljs-built_in">int</span> res=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>,j=a;i&lt;=b;i++,j--)&#123;<br>res=(LL)res *j %p;<br>res=(LL)res *qmi(i,p-<span class="hljs-number">2</span>)%p;<br>&#125;<br>return res;<br>&#125;<br><span class="hljs-comment">//卢卡斯定理</span><br><span class="hljs-built_in">int</span> <span class="hljs-constructor">Lucas(LL <span class="hljs-params">a</span>,LL <span class="hljs-params">b</span>)</span>&#123;<br><span class="hljs-keyword">if</span>(a%p&amp;&amp;b&lt;p) return <span class="hljs-constructor">C(<span class="hljs-params">a</span>,<span class="hljs-params">b</span>)</span>;<br>return (LL)<span class="hljs-constructor">C(<span class="hljs-params">a</span>%<span class="hljs-params">p</span>,<span class="hljs-params">b</span>%<span class="hljs-params">p</span>)</span>*<span class="hljs-constructor">Lucas(<span class="hljs-params">a</span><span class="hljs-operator">/</span><span class="hljs-params">p</span>,<span class="hljs-params">b</span><span class="hljs-operator">/</span><span class="hljs-params">p</span>)</span>%p;<br>&#125;<br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span>&#123;<br><span class="hljs-built_in">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">while</span>(n--)&#123;<br>LL a,b;<br>cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;<br>cout &lt;&lt; <span class="hljs-constructor">Lucas(<span class="hljs-params">a</span>,<span class="hljs-params">b</span>)</span>&lt;&lt;endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="高精度法"><a href="#高精度法" class="headerlink" title="高精度法"></a>高精度法</h5><p>如果我们不能求余，必须要把组合数用高精度求出确定值。我们就不能使用上述递推、预处理、卢卡斯定理方法。只能使用高精度乘法和高精度除法的结合套组合数公式。具体略</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetbook算法笔记（五）图初步</title>
    <link href="/2023/05/13/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E5%9B%BE%E5%88%9D%E6%AD%A5/"/>
    <url>/2023/05/13/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E5%9B%BE%E5%88%9D%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p>常见的图有三种：无向图、有向图、加权图</p></li><li><p>常见的存图法有三种</p><ul><li><p>邻接矩阵</p><ul><li><p>如果con[i] [j]的值为true，则有一个i-&gt;j的有向边</p></li><li><p>无向边则需要令con[i] [j] 和con[j] [i]都为true</p></li><li><p>该方法不适合稀疏图和大型图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//邻接矩阵</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxVertexNum 100<span class="hljs-comment">//顶点数目的最大值</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VertexType;<span class="hljs-comment">//顶点的数据类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> EdgeType;<span class="hljs-comment">//带权图中边上权值的数据类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>VertexType Vex[MaxVertexNum];<span class="hljs-comment">//顶点表</span><br>EdgeType Edge[MaxVertexNum][MaxVertexNum];<span class="hljs-comment">//邻接矩阵，边表</span><br><span class="hljs-type">int</span> vexnum, arcnum;<span class="hljs-comment">//图的当前顶点数和弧树</span><br>&#125;MGraph;<br><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>邻接表</p><ul><li><p>对于图，我们往往更加关注哪些点之间有连边，而不关注哪些点之间没有连边</p></li><li><p>对有向图G，把同一个顶点的所有<strong>出边</strong>放在一个列表中，那么N个顶点就有N个列表（没有出边也是空表）。这N个列表成为图G的邻接表</p></li><li><p>需要注意的是，每个顶点的出边单链表实际上存的是顶点下标，下标才能索引，值无法索引</p></li><li><p><img src="/2023/05/13/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E5%9B%BE%E5%88%9D%E6%AD%A5/image-20240124111618115.png" alt="image-20240124111618115"></p></li><li><p>对无向图，即可不分出入边，将所有邻边存入邻接表</p></li><li><p><img src="/2023/05/13/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E5%9B%BE%E5%88%9D%E6%AD%A5/image-20240124111850825.png" alt="image-20240124111850825"></p></li><li><p>链表可以手打，亦可以使用vector</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//不存放边权的邻接表</span><br>vector&lt;<span class="hljs-type">int</span>&gt; Adj[N];<br><span class="hljs-comment">/*****************/</span><br><span class="hljs-comment">//如果想建立边权，可以建立结构体Node，可以存放其他信息</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> nxt;<span class="hljs-comment">//边终点</span><br>    <span class="hljs-type">int</span> val;<span class="hljs-comment">//边权</span><br>&#125;;<br>vector&lt;Node&gt; Adj[N];<br><span class="hljs-comment">//添加边 从i结点指向j权值为5</span><br>Adj[i].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">node</span>(j,<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure></li></ul></li><li><p>链式前向星存储</p></li></ul><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="图的深度优先搜索法（DFS）"><a href="#图的深度优先搜索法（DFS）" class="headerlink" title="图的深度优先搜索法（DFS）"></a>图的深度优先搜索法（DFS）</h4><p>“一条路走到底，不撞南墙不回头”，可以在图中遍历所有顶点，和任意两点间的所有路径。</p><ul><li>遍历所有顶点<ul><li>使用递归的隐式栈（先入后出）实现<img src="/2023/05/13/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E5%9B%BE%E5%88%9D%E6%AD%A5/image-20240124192046011.png" alt="image-20240124192046011"><ol><li>元素A先入栈再出栈检查，通过标记检查a是否访问过。如没有，标记为“已访问”。</li><li>将与A相接的所有点入栈待查，将栈顶元素如B取出检查，如第一步。</li><li>将与B相接的所有点入栈待查，将栈顶元素取出待查。</li><li>重复，如果所有元素都访问过则退到上一顶点，即继续取栈顶元素。</li><li>重复，直到栈排空，意味着所有顶点都标记为已访问。</li></ol></li></ul></li></ul><ul><li>图的深度优先遍历的结果并不唯一</li><li>遍历两点之间所有路径用DFS。遍历无向图路径时，需要标记重复路径，从栈中取出元素后若要回退要再把标记置为未访问。有向图不用。</li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">//图上DFS</span><br>typedef <span class="hljs-keyword">struct</span> <span class="hljs-type">graph</span> &#123;<br><br>&#125;<span class="hljs-keyword">Graph</span>;<br></code></pre></td></tr></table></figure><h4 id="图的广度优先搜索法（BFS）"><a href="#图的广度优先搜索法（BFS）" class="headerlink" title="图的广度优先搜索法（BFS）"></a>图的广度优先搜索法（BFS）</h4><ul><li>由于 图中存在环，和深度优先遍历一样，广度优先遍历也需要在遍历的时候记录已经遍历过的结点。特别注意：将结点添加到队列以后，一定要马上标记为「已经访问」，否则相同结点会重复入队，这一点在初学的时候很容易忽略。</li></ul><ul><li>在无权图中，由于广度优先搜索本身特点，假如源点为<code>source</code>，只有在遍历到所有距离源点<code>source</code>距离为<code>d</code>的所有结点之后，才能遍历到任何距离源点为<code>d+1</code>距离的所有结点。</li></ul><ul><li>所以通过BFS很容易得到从源点到目标结点的最短路径，在最短路径问题上BFS比DFS更加高效。</li></ul><h3 id="图的最短路径"><a href="#图的最短路径" class="headerlink" title="图的最短路径"></a>图的最短路径</h3><p>广度优先遍历用于求解<strong>无权图</strong>的最短路径。有两种方式，一是求所有路径取最短，二是直接取最短路径。</p><p><img src="/2023/05/13/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E5%9B%BE%E5%88%9D%E6%AD%A5/image-20240130110242618.png" alt="image-20240130110242618"></p><p>一，求所有路径取最短</p><ul><li>起点<code>a</code>入队列，取出队头路径最后一个元素（仍然是<code>a</code>），将其所有路径<code>[a,c] [a,d] [a,b]</code>放入队列。标记A出边已经被访问完全，队头<code>a</code>出队。</li><li>取队头路径<code>[a,c]</code>最后一个元素<code>c</code>，将其路径<code>[a,c,e]</code>放入队列。标记c出边已经被访问完全，出队。</li><li>取队头路径<code>[a,d]</code>最后一个元素<code>d</code>，重复。</li><li>出完路径队列，取最小结果</li></ul><p>二、直接取最短路径</p><ul><li>其实无需出完路径队列，第一个抵达终点的路径就是最短路径。原理见<strong>图的广度优先搜索法（BFS）</strong>。</li></ul><p>如果是<strong>带权图</strong>就需要专门的算法。</p><h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><p>带权有向，权非负的单源最短路径问题</p><ul><li>主要思想<ol><li>对图设置集合<code>S</code>，存放已经被访问的顶点，然后从集合<code>non-S</code>中选择与<u>起点s</u>的最短距离最小的一个顶点<code>u</code>，访问并加入集合<code>S</code></li><li>之后令<code>u</code>为中介点，优化起点s与所有u能访问的顶点v之间的最短距离。</li><li>重复2. n次（n为顶点个数），直到集合S已经包含所有顶点。</li></ol></li></ul><h4 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h4><p>带权有向，无负权环的单源最短路径问题</p><ul><li>基础定理<ul><li>在一个有N个顶点的非负权环图中，两点之间的最短路径最多经过N-1条边</li><li>零权，正权环不会影响最短路径求解。负权环没有最短路径，BF算法不能计算，但可以检测负权环。</li></ul></li><li>基本思路<ul><li>对图中的边进行N-1轮操作，每轮都遍历图中所有边，记从源点可及的各个顶点为为数组<code>d[]</code></li><li>对每条边<code>u-&gt;v</code>,若以u为中介点可以使得<code>d[v]</code>更小，就以现在的<code>d[u]+length[u-&gt;v]</code>更新<code>d[v]</code></li></ul></li></ul><h4 id="基于队列优化的Bellman-Ford算法-SPFA算法"><a href="#基于队列优化的Bellman-Ford算法-SPFA算法" class="headerlink" title="基于队列优化的Bellman-Ford算法(SPFA算法)"></a>基于队列优化的Bellman-Ford算法(SPFA算法)</h4><h4 id="Floyd-Warshall算法"><a href="#Floyd-Warshall算法" class="headerlink" title="Floyd-Warshall算法"></a>Floyd-Warshall算法</h4><p>所有结点对的最短路径问题</p><h3 id="图的最小生成树"><a href="#图的最小生成树" class="headerlink" title="图的最小生成树"></a>图的最小生成树</h3><p>最小生成树是在一个给定的无向图G中求一棵树T，该树拥有G中的所有顶点，且所有边都是G中的边，还满足树边权之和最小。</p><p>最小生成树有如下性质：</p><ul><li>最小生成树是树，所以边数等于顶点数-1，且树内一定无环。</li><li>对于图G，其最小生成树可以不唯一，但其边权之和肯定唯一最小</li><li>由于最小生成树是在无向图上生成的，所以其根节点可以是这棵树上的任意一个结点，为了使得根节点唯一，题目一般会给出根节点。</li></ul><h4 id="切分定理"><a href="#切分定理" class="headerlink" title="切分定理"></a>切分定理</h4><p>将图切为两个部分称之为一个<strong>切分</strong>，如图，其中(B,A,E)为一部分，(C,D)为另一部分。</p><p>如果一条边连接的两个顶点属于切分的两个部分，这个边称为<strong>横切边</strong>。</p><p><img src="/2023/05/13/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E5%9B%BE%E5%88%9D%E6%AD%A5/image-20240130164137510.png" alt="image-20240130164137510" style="zoom:80%;"></p><p>切分定理指的是：</p><p>​    在一幅连通带权无向图中，给定任意的切分，如果有一条横切边的权值严格小于所有其他横切边，那么这条边必然属于该图最小生成树中的一条边。</p><p>这是Kruskal算法和Prim算法的理论支撑。此外，Kruskal和Prim算法都使用了贪心思想，只是贪心的重点不一样，可以带着这个特点去理解。有关贪心思想见贪心算法专题。</p><h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><ul><li><p>基本思想：</p><ol><li>初始状态先隐去图中的所有边，这样图中每个顶点都自成一个连通块，之后：</li><li>对所有边按边权从小到大进行排序。</li><li>按边权从小到大测试所有边，如果当前测试边所连接的两个顶点不在同一个就将这条测试边加入当前最小生成树中；否则舍弃边。</li><li>重复执行步骤3. 直到最小生成树的边数等于总顶点数-1，此时最小生成树已完成；或是测试完所有边仍未达到边数要求，此时此图不连通。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//todo Kruskal算法模板</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><ul><li>基本思想：<ol><li>对图设置集合<code>S</code>，存放已经被访问的顶点，然后从集合<code>non-S</code>中选择与<u>集合S</u>的最短距离最小的一个顶点<code>u</code>，访问并加入集合<code>S</code></li><li>之后令<code>u</code>为中介点，优化所有从从<code>u</code>能到达的顶点<code>v</code>与集合<code>S</code>的最短距离.</li><li>重复2. <code>n</code>次（<code>n</code>为顶点个数），直到<code>S</code>包含所有顶点</li></ol></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>todo<br></code></pre></td></tr></table></figure><ul><li>Prim算法和Dijkstra算法思路相同，关注部分不同</li></ul><h3 id="图的拓扑排序和关键路径"><a href="#图的拓扑排序和关键路径" class="headerlink" title="图的拓扑排序和关键路径"></a>图的拓扑排序和关键路径</h3><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><p>如果有向图G的任意顶点都无法通过一些有向边回到自身，那么称这个图为<strong>有向无环图</strong>。</p><p>对有向无环图G的所有顶点排成一个线性序列，使得对G的任意两个顶点u、v，如果存在边u-&gt;v，那么在序列中u一定在v之前，这个序列称为<strong>拓扑序列</strong>。</p><ul><li><strong>kahn算法思路</strong><ol><li>定义一个队列Q，将所有入度为零的结点加入队列</li><li>取队首结点，输出。之后删去所有从它出发的边，并令这些边到达的顶点其入度-1。如果某个顶点的入度减为0则加入队列。</li><li>反复进行2.操作，直到队列为空。如果队列为空时，入过队的节点数目恰好为N，说明拓扑排序成功。否则G中有环，排序失败。</li></ol></li></ul><h4 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h4><p>用顶点表示活动，边集表示活动间隔的有向图称为<strong>顶点活动网（AOV网）</strong></p><p>用带权边集表示活动，顶点表示事件的有向图称为<strong>边活动网（AOE网）</strong></p><p>逻辑正确的AOV网和AOE网都是有向无环图，如果给定AOV网中各个顶点活动需要的时间，就可以将AOV网转换成AOE网。</p><p>AOE网解决两个问题：①从起始到终止需要多长时间②哪些路径上的活动是影响工程的关键。</p><p>我们把AOE网中的最长路径称为<strong>关键路径</strong>，关键路径上的活动即是<strong>关键活动</strong>/</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图</tag>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetbook算法笔记（四）树初步、并查集</title>
    <link href="/2023/05/02/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%A0%91%E5%88%9D%E6%AD%A5%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2023/05/02/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%A0%91%E5%88%9D%E6%AD%A5%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>根左右，先访问根节点，然后遍历左子树，最后遍历右子树</p><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>左根右，先遍历左子树，然后访问根节点，然后遍历右子树。</p><p>对于二叉搜索树，我们可以通过中序遍历得到一个递增的有序序列。 </p><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>左右根，先遍历左子树，然后遍历右子树，最后遍历根节点</p><p>前三种都是深度优先搜索DFS</p><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>层序遍历即逐层遍历树结构，是广度优先搜索</p><ul><li>编程思路<ol><li>根节点root加入队列。</li><li>取出队首结点，访问它。<ol><li>如果结点有左孩子，左孩子入队。</li><li>如果结点有右孩子，右孩子入队。</li></ol></li><li>返回2. 直到取完队列，队列为空。</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//层序遍历使用队列</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOreder</span>(TreeNode* root)&#123;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-comment">//空节点即返回</span><br>        <span class="hljs-keyword">if</span>(root=<span class="hljs-literal">nullptr</span>)  <span class="hljs-keyword">return</span> ans;<br>        TreeNode* tn=root;<br>        queue&lt;TreeNode&gt; layer;<br>        layer.<span class="hljs-built_in">push</span>(tn);<span class="hljs-comment">//队首为根节点</span><br>        <span class="hljs-comment">//直到队列为空</span><br>        <span class="hljs-keyword">while</span>(!layer.<span class="hljs-built_in">empty</span>())&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; this_layer;<br>            <span class="hljs-type">int</span> qsize=layer.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> tmp=<span class="hljs-number">0</span>;tmp&lt;qsize;tmp++)&#123;<br>                <span class="hljs-comment">//每次返回队首</span><br>tn =layer.<span class="hljs-built_in">front</span>();<br>                layer.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//队首出队</span><br>                this_layer.<span class="hljs-built_in">push_back</span>(tn-&gt;val);<br>                <span class="hljs-comment">//左</span><br>                <span class="hljs-keyword">if</span>(tn-&gt;left) layer.<span class="hljs-built_in">push</span>(tn-&gt;left);<br>                <span class="hljs-comment">//右</span><br>                <span class="hljs-keyword">if</span>(tn-&gt;right) layer.<span class="hljs-built_in">push</span>(tn-&gt;left);<br>            &#125;<br>        <span class="hljs-comment">//将每层结果添加进输出中</span><br>        ans.<span class="hljs-built_in">push_back</span>(this_layer);<br>        &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a>树的应用</h3><h4 id="二叉搜索树-二叉查找树，二叉排序树，BST"><a href="#二叉搜索树-二叉查找树，二叉排序树，BST" class="headerlink" title="二叉搜索树(二叉查找树，二叉排序树，BST)"></a>二叉搜索树(二叉查找树，二叉排序树，BST)</h4><ul><li>定义：<ul><li>要么是空树，要么根节点下的左子树右子树都是BST</li><li>左子树上所有结点的数据域均小于等于根节点上的数据域</li><li>右子树上所有结点的数据域均大于等于根节点上的数据域</li></ul></li><li>重要性质<ul><li>中序遍历的结果是值递增的有序序列</li></ul></li></ul><h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h5><h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><ul><li><p>堆是一种特别的二叉树，是</p><ul><li>完全二叉树</li><li>每个结点的值都必须大于等于或小于等于其子结点的值<ul><li>每一结点都大于等于子结点值的堆为最大堆，根结点（堆顶）为堆最大值</li><li>每一结点都小于等于子结点值的堆为最小堆，根结点（堆顶）为堆最小值</li></ul></li></ul></li><li><p>对于堆</p><ul><li>插入O (logN)</li><li>删除O (logN) 删除是是指删除堆顶元素</li><li>获取最值O (1)</li><li>插入删除后，仍需要维持它的特性</li></ul></li><li><p>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//最大堆</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxHeap</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; heap;<br>    <span class="hljs-comment">//堆大小</span><br>    <span class="hljs-type">int</span> heapSize;<br>    <span class="hljs-comment">//实际大小</span><br>    <span class="hljs-type">int</span> realSize;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MaxHeap</span>(<span class="hljs-type">int</span> size):<span class="hljs-built_in">heapSize</span>(size),<span class="hljs-built_in">realSize</span>(<span class="hljs-number">0</span>),<span class="hljs-built_in">heap</span>(size+<span class="hljs-number">1</span>)&#123;heap[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;&#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> heap[<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> realSize;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> elem)</span></span>&#123;<br>        realSize++;<br>        <span class="hljs-keyword">if</span>(realSize&gt;heapSize)&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;elems exceeded&quot;</span>&lt;&lt;endl;<br>            realSize--;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        heap[realSize]=elem;<br>        <span class="hljs-type">int</span> elemID=realSize;<br>        <span class="hljs-type">int</span> parentID=elemID/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(heap[elemID]&gt;heap[parentID]&amp;&amp;elemID&gt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">int</span> temp=heap[elemID];<br>            heap[elemID]=heap[parentID];<br>            heap[parentID]=temp;<br>            elemID=parentID;<br>            parentID=elemID/<span class="hljs-number">2</span>; <br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(realSize&lt;<span class="hljs-number">1</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;elems emptied&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">return</span> INT32_MIN;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> heapTop=heap[<span class="hljs-number">1</span>];<br>            heap[<span class="hljs-number">1</span>]=heap[realSize];<br>            realSize--;<br>            <span class="hljs-type">int</span> elemID=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (elemID&lt;realSize&amp;&amp;elemID&lt;=realSize/<span class="hljs-number">2</span>)<br>            &#123;<br>                <span class="hljs-type">int</span> left=elemID*<span class="hljs-number">2</span>;<br>                <span class="hljs-type">int</span> right=(elemID*<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(heap[elemID]&lt;heap[left]||heap[elemID]&lt;heap[right])&#123;<br>                    <span class="hljs-keyword">if</span>(heap[left]&gt;heap[right])&#123;<br>                        <span class="hljs-type">int</span> temp = heap[left];<br>                        heap[left]=heap[elemID];<br>                        heap[right]=temp;<br>                        elemID=left;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-type">int</span> temp = heap[right];<br>                        heap[right]=heap[elemID];<br>                        heap[left]=temp;<br>                        elemID=right;<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">break</span>;&#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> heapTop;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">toStr</span><span class="hljs-params">()</span></span>&#123;<br>        string fin;<br>        stringstream tempss;<br>        <span class="hljs-built_in">copy</span>(heap.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>,heap.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">ostream_iterator</span>&lt;<span class="hljs-type">int</span>&gt;(tempss,<span class="hljs-string">&quot;&quot;</span>));<br>        fin=tempss.<span class="hljs-built_in">str</span>();<br>        <span class="hljs-keyword">return</span> fin;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集是一种维护集合的数据结构，“并”指的是“合并（Union）”“查”指的是“查找（find）”，“集”指的是“集合（set）”。并查集主要解决网络连通性问题。</p><h3 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h3><ul><li>父结点，是某顶点直接的父亲节点。</li><li>根节点，是没有父结点的结点，其本身也可以视为自己的父结点。</li><li>对同一个集合来说只存在一个根节点，且其为所属集合的标识。</li></ul><h3 id="编程思路"><a href="#编程思路" class="headerlink" title="编程思路"></a>编程思路</h3><ul><li><p>找到不同元素他们的根节点，根节点相同，为同一集合；根节点不同，为不同集合。</p></li><li><p>合并，合并两个集合。将其中一个集合的根结点的父亲指向另一个集合的根节点</p></li><li><p>查找，判断两个元素是否是一个集合。通过找到给定顶点的根结点实现。</p></li><li><p>借用数组，数组存储顶点，索引是顶点、值存储父结点的索引</p><ul><li><p>Quick Find 实现，数组元素值存的是根结点。</p></li><li><p>Quick Union实现，数组元素值存的是父结点。一般使用这个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//QU实现,使用数组实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickUnion</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> root[];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">QuickUnion</span>(<span class="hljs-type">int</span> size)&#123;<br>        root=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            root[i]=i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-comment">//一直向上查找直到父结点为自身的根节点</span><br>        <span class="hljs-keyword">while</span>(x!=root[x])&#123;<br>            x=root[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-type">int</span> rootX=<span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-type">int</span> rootY=<span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-comment">//如果XY根节点不一致，使一个集合的根节点的父亲指向另一个集合的根节点</span><br>        <span class="hljs-keyword">if</span>(rootX!=rootY) root[rootY]=rootX;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="按秩合并优化"><a href="#按秩合并优化" class="headerlink" title="按秩合并优化"></a>按秩合并优化</h4><p>按秩合并的意思是，让数的秩较小的数的根节点，指向树的秩较大的树的根节点。</p><p>这里的<strong>秩</strong>有两种情况分别适用于不同场景</p><ul><li>按size（结点数量）合并，用于需要维护每个连通分量结点个数的时候。</li><li>按rank（结点层数）合并，绝大多数情况用这个。</li></ul><h4 id="路径压缩优化"><a href="#路径压缩优化" class="headerlink" title="路径压缩优化"></a>路径压缩优化</h4><p>路径压缩也有两种方法</p><ul><li>隔代压缩：两步一跳，一直循环执行「把当前结点指向它的父亲结点的父亲结点」这样的操作</li><li>完全压缩：把从「查询结点」到「根结点」沿途经过的所有结点都指向根结点，下一次就可以直接访问到根节点。</li></ul><h4 id="基于路径压缩的按秩合并优化"><a href="#基于路径压缩的按秩合并优化" class="headerlink" title="基于路径压缩的按秩合并优化"></a>基于路径压缩的按秩合并优化</h4>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetbook算法笔记（三）排序专题</title>
    <link href="/2023/02/20/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/"/>
    <url>/2023/02/20/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h3><ul><li>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] = r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的。如{3,  1,  2_1, 2_2 }排序为{1, 2_2, 2_1, 3 }就是不稳定的。</li></ul><ul><li>稳定性的意义：当要排序的内容是一个对象的多个属性，且其原本的顺序存在意义时，如果我们需要在二次排序后保持原有排序的意义，就需要稳定算法</li></ul><h3 id="时间复杂度O-n-2-级别排序"><a href="#时间复杂度O-n-2-级别排序" class="headerlink" title="时间复杂度O(n^2)级别排序"></a>时间复杂度O(n^2)级别排序</h3><h4 id="🚩冒泡排序"><a href="#🚩冒泡排序" class="headerlink" title="🚩冒泡排序"></a>🚩冒泡排序</h4><ul><li><p>基础写法：双重循环遍历，一边比较一边将较大值或较小值两两交换，将最大或最小值冒泡到最后一位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;array.length<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;array.length<span class="hljs-number">-1</span>-i;j++)&#123;<br>        <span class="hljs-keyword">if</span> (array[j] &gt; array[j + <span class="hljs-number">1</span>]) &#123;<br><span class="hljs-built_in">swap</span>(array,j,j+<span class="hljs-number">1</span>);<br>        &#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//由外到内，第一个循环保证比较所有数，第二个循环保证正在进行比较的单个数和后边所有数都要比较</span><br></code></pre></td></tr></table></figure></li><li><p>优化写法：使用一个变量记录当前轮次的比较是否发生交换，如果没有交换表示已经有序不再排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">boolean swaped;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;array.length<span class="hljs-number">-1</span>;i++)&#123;<br>    <span class="hljs-comment">//首先该轮比较暂没有交换</span><br>    swapped=<span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;array.length<span class="hljs-number">-1</span>-i;j++)&#123;<br>        <span class="hljs-keyword">if</span>(array[j]&gt;array[j+<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-built_in">swap</span>(array,j,j+<span class="hljs-number">1</span>);<br>            swapped=<span class="hljs-literal">true</span>;<br>        &#125;<br>&#125;<br>    <span class="hljs-comment">//如果没有交换则不再向后比较，已经有序</span><br>    <span class="hljs-keyword">if</span>(!swapped) <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对于swap函数来说，也有三种交换方法 临时数方法、加减运算法、异或运算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 方法一: 利用临时数tmp</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    <span class="hljs-type">int</span> tmp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = tmp;<br>&#125;<br><span class="hljs-comment">// 方法二: 利用加减运算</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">swapCal</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(i == j) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 若无法保证swapCal被调用时满足 i != j，则需有此句，否则i == j时此数将变为0</span><br>    arr[i] = arr[i] + arr[j]; <span class="hljs-comment">// a = a + b</span><br>    arr[j] = arr[i] - arr[j]; <span class="hljs-comment">// b = a - b</span><br>    arr[i] = arr[i] - arr[j]; <span class="hljs-comment">// a = a - b</span><br>&#125;<br><span class="hljs-comment">// 方法三: 利用异或运算</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">swapXOR</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(i == j) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 若无法保证swapXOR被调用时满足 i != j，则需有此句，否则i == j时此数将变为0</span><br>    arr[i] = arr[i] ^ arr[j]; <span class="hljs-comment">// a = a ^ b，也可写成 arr[i] ^= arr[j];</span><br>    arr[j] = arr[i] ^ arr[j]; <span class="hljs-comment">// b = (a ^ b) ^ b = a ^ (b ^ b) = a ^ 0 = a， 也可写成 arr[j] ^= arr[i];</span><br>    arr[i] = arr[i] ^ arr[j]; <span class="hljs-comment">// a = (a ^ b) ^ a = (a ^ a) ^ b = 0 ^ b = b， 也可写成 arr[i] ^= arr[j];</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>  ​    </p><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><ul><li><p>基础写法：双重循环遍历数组，每一轮比较，可找到本轮最小元素的<strong>下标</strong>，将其交换至本轮的首位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> minid;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;array.length<span class="hljs-number">-1</span>;i++)&#123;  <span class="hljs-comment">//注意最后一个数不用再新一轮比较</span><br>    minid=i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;array.length;j++)&#123;<span class="hljs-comment">//注意要从i+1比较到最后一个数</span><br>        <span class="hljs-keyword">if</span>(array[minid]&gt;array[j])&#123;<br>            minid=j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">swap</span>(array,minid,j);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p><strong>二元选择排序</strong>写法：每轮比较时记录最小值和最大值的下标，可以把数组需要遍历的范围缩小一倍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] <span class="hljs-built_in">selectionSortDouble</span>(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-keyword">if</span> (arr.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-type">int</span> n = arr.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span> - i; i++) &#123; <span class="hljs-comment">// 每轮确定两个数字，因此上界也会动态变化</span><br>        <span class="hljs-type">int</span> minIdx = i, maxIdx = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIdx]) minIdx = j;<br>            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[maxIdx]) maxIdx = j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(minIdx == maxIdx) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 若本轮最大值等于最小值，说明未排序部分所有元素相等，无需再排序</span><br>        <span class="hljs-built_in">swap</span>(arr, i, minIdx); <br>        <span class="hljs-keyword">if</span>(maxIdx == i) maxIdx = minIdx; <span class="hljs-comment">// 在交换 i 和 minIdx 时，有可能出现 i 即 maxIdx 的情况，此时需要修改 maxIdx 为 minIdx</span><br>        <span class="hljs-built_in">swap</span>(arr, n - <span class="hljs-number">1</span> - i, maxIdx); <br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><ul><li><p>交换法：从第二个数字开始，不断与前面数字交换，到大小合适不能交换为止</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 交换法插入排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_sort1</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[j] &gt; nums[j + <span class="hljs-number">1</span>]; --j)<br>        &#123;<br>            <span class="hljs-built_in">swap</span>(nums[j], nums[j + <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><ul><li><p>移动法：从第二个数字开始，不断与前面的数字比较，前面数字不断向后移动，到合适位置插入一次即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 移动法插入排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_sort2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-type">int</span> t = nums[i]; <span class="hljs-comment">// 暂存需要插入的数字</span><br>        <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (j; j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[j] &gt; t; --j)<br>        &#123;<br>            nums[j + <span class="hljs-number">1</span>] = nums[j];<br>        &#125;<br>        nums[j + <span class="hljs-number">1</span>] = t;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="时间复杂度O-nlogn-级别排序"><a href="#时间复杂度O-nlogn-级别排序" class="headerlink" title="时间复杂度O(nlogn)级别排序"></a>时间复杂度O(nlogn)级别排序</h3><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h5><ol><li>将待排序数组按照一定间隔分为多个子数组，即为每跳跃一定间隔取一个值组成一组，每组分别进行插排</li><li>逐渐缩小间隔进行下一轮排序</li><li>最后一轮时间隔为一，即为直接插排。而因为此时数组已经基本有序，故只需少量交换。</li></ol><p>希尔排序对有序程度较高的序列有较高的效率</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//基础写法 /希尔增量序列Dm=N/2 Dk=(D(k+1))/2</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> gap = array.len/<span class="hljs-number">2</span>;gap&gt;<span class="hljs-number">0</span>;gap/=<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-comment">//分组，直到gap=1或ID到组尾</span><br>    <span class="hljs-comment">//但对于计算机来说，它更喜欢从第 gap 个元素开始，按照顺序将每个元素依次向前插入自己所在的组这种方式</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> groupStartID=<span class="hljs-number">0</span>;groupStartID&lt;gap;groupStartID++)&#123;<br><span class="hljs-comment">//插排,每组第二个往后开始站起来找位置，组内每个数隔一个gap</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> currentID=groupStartID+gap;<br>            currentID&lt;array.len;couuentID+=gap)&#123;<br>            <span class="hljs-comment">//挑出来开始找位置</span><br>            <span class="hljs-type">int</span> currentNum=array[currentID];<br>            <span class="hljs-comment">//preID:该组该数前一个数的ID </span><br>            <span class="hljs-comment">//直到preID到小组开始且当前挑出数小于小组前一个数为止</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> preID=currentID-gap;<br>                preID&gt;=groupStartID&amp;&amp;currentNum&lt;array[preID];<br>                preID-=gap)&#123;<br>                <span class="hljs-comment">//向后挪位置</span><br>                arr[preID+gap]=arr[preID];<br>            &#125;<br>            <span class="hljs-comment">//currentNum到位</span><br>            arr[preIndex + gap] = currentNum;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>常见增量序列</p><ul><li><p>Hibbard增量序列(1,3,7,15,…):</p><script type="math/tex; mode=display">D_k=2^k-1</script></li><li><p>Knuth增量序列(1,4,13,40,..):</p></li></ul><script type="math/tex; mode=display">D_1=1;D_{k+1}=3·D_k+1</script><ul><li>Sedgewick增量序列</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//求Knuth增量序列</span><br><span class="hljs-type">int</span> maxKnuthNum=<span class="hljs-number">1</span>;<br><span class="hljs-comment">//找最大Knuth数</span><br><span class="hljs-keyword">while</span>(maxKnuthNum&lt;=arr.len/<span class="hljs-number">3</span>)&#123;<br>    maxKnuthNum=maxKnuthNum*<span class="hljs-number">3</span>+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> gap=maxKnuthNumber;gap&gt;<span class="hljs-number">0</span>;gap=(gap<span class="hljs-number">-1</span>)/<span class="hljs-number">3</span>)&#123;<br>    <span class="hljs-comment">//对于计算机来说，它更喜欢从第 gap 个元素开始，按照顺序将每个元素依次向前插入自己所在的组这种方式</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=gap;i&lt;arr.len;i++)&#123;<br>        <span class="hljs-type">int</span> currNum=arr[i];<br>        <span class="hljs-type">int</span> preID=i-gap;<br>        <span class="hljs-keyword">for</span>(;preID&gt;=<span class="hljs-number">0</span>&amp;&amp;currNum&lt;arr[preID];<br>            preID-=gap)&#123;<br>            arr[preID+gap]=arr[preID];<br>        &#125;<br>        arr[preID+gap]=currNum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h5><p>希尔排列是较早地<strong>突破二次复杂度</strong>的排序算法，我们可以从<strong>逆序数</strong>的角度考察它为何能突破O(n^2)</p><p>在一个排列中如果任意一对数的前后位置与大小顺序相反，即前大后小，则这两个数构成<strong>逆序</strong>，一个排列中逆序的总数就是一个<strong>逆序数</strong>。任何排序都在减少逆序数直到为0</p><p>回顾冒泡排序和简单插入排序，它们每次交换只交换<strong>相邻</strong>元素，那么每次交换只能减少一个逆序。如果能跨越多个元素进行交换就<strong>可能</strong>一次减少多个逆序。选择排序确实是跨越多个元素的交换，实际上它减少逆序数的操作时间复杂度为O(n)，但它需要两轮比较，比较次数仍为O(n^2),所以选择排序整体复杂度为二次。</p><p>所谓“可能减少逆序”的情况，比如<img src="/2023/02/20/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/image-20240205112753322.png" alt="image-20240205112753322"></p><p>我们只交换了i和j，就使得逆序数由3变成了0。当然只是有可能出现这种情况。</p><p>这些O(nlogn)的排序，即希尔排序、堆排序、快速排序、归并排序都是实现了<strong>长距离交换元素</strong>进而使得时间复杂度优于二次</p><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h5><p>堆排序先将输入数组使用<strong>堆化方法(heapify)</strong>建立为一个<strong>大顶堆</strong>，反复取出堆顶并逆序排列，对剩余元素重建大顶堆，直到堆顶都拿出，即可将原数组从小到大完成排序。</p><blockquote><p>[!NOTE]</p><p>堆是符合一下两个条件之一的完全二叉树</p><ul><li>根结点的值&gt;=子结点的值，称之为最大堆或大顶堆</li><li>根结点的值&lt;=子结点的值，称之为最小堆或小顶堆</li></ul><p>完全二叉树是结点按从上至下、从左到右的顺序排列的二叉树</p></blockquote><p>一个直接的想法是在原数组之外新建一个数组来保存每次取得的堆顶，但这样会有O(n)级别的空间开销，一般用原地堆排序的技巧避免此开销</p><h5 id="原地堆排序"><a href="#原地堆排序" class="headerlink" title="原地堆排序"></a>原地堆排序</h5><ol><li>将原来待排序数组arr[]使用堆化方法建立为一个大顶堆。</li><li>交换堆顶和当前<strong>未排序部分</strong>最末尾元素，则堆顶元素得到排序（此时在数组最末尾）</li><li>剩余元素中只可能是当前堆顶（即上一步被交换的末尾元素）会造成堆失序，因此需要对堆顶调用一次调整堆序的下滤方法，恢复未排序部分的堆序</li><li>重复2 3，直到所有元素已排序</li></ol><h5 id="堆化过程-heapify"><a href="#堆化过程-heapify" class="headerlink" title="堆化过程(heapify)"></a>堆化过程(heapify)</h5><p>将待排序数组arr[]看作一个根结点为0的<strong>完全二叉树</strong>，那么其任意一个结点（假设下标为i）的左子结点下标为$2·i+1$，右子结点下标为$2·i+2$，父结点为$(i-1)/2$。</p><p>堆化过程就是使整个树满足堆序性质的过程，即使得大顶堆arr的$arr[ (i-1)/2 ]&gt;=arr[ 2·i+1 ]且arr[ (i-1)/2 ]&gt;=arr[ 2·i+2 ]$，亦即任意一个结点大于等于其子结点。</p><p>而使得堆化过程实现的具体操作叫做（大顶堆的）<strong>下滤方法</strong>。依次对从最后一个<strong>非叶子结点</strong>到根结点执行下滤方法，即为堆化过程</p><blockquote><p>[!NOTE]</p><p>叶子节点无子结点，也就无下滤的必要。</p><p>最后一个非叶子结点下标为$(n-1)/2$,n为数组长度</p></blockquote><h5 id="下滤方法-siftdown"><a href="#下滤方法-siftdown" class="headerlink" title="下滤方法(siftdown)"></a>下滤方法(siftdown)</h5><p>下滤方法是堆排序的<strong>核心</strong>方法，在原地堆排序中有两处应用</p><ul><li>排序开始前，创建大顶堆（堆化过程）时使用下滤方法</li><li>原地排序时，对堆顶恢复未排序部分的<strong>堆序</strong></li></ul><blockquote><p>[!note]</p><p>此处不要模糊我们排序的最终目标是<strong>序列有序</strong>，序列有序（以从大到小为例）体现在树上就是父结点&gt;左子结点&gt;右子结点。而<strong>堆有序</strong>（以大顶堆为例），仅仅是父结点&gt;左结点且父结点&gt;右节点，对左右结点的关系没有要求。</p></blockquote><p>下滤方法在堆数据结构中用于堆顶元素的删除操作，先来理解它如何删除堆顶</p><ol><li>删除堆顶，堆中元素-1，将当前序列最后一个元素<strong>暂时</strong>置为堆顶</li><li>此时只有堆顶元素导致堆失序，于是<strong>交换其与左右子结点的较大者</strong></li><li>重复2 直到恢复堆序</li></ol><p>我们注意到<strong>交换父结点与左右子结点的<em>较大者</em></strong>这一步能够将堆有序转化为序列有序，因为它消除了左右子结点的逆序。这是下滤方法的本质。</p><p>理解了下滤方法删除堆顶，我们再回顾堆化过程，堆化过程就是分别对从最后一个<strong>非叶子结点</strong>到根结点执行下滤方法。</p><p>堆化之后的原地排序就是，每次交换当前堆顶和当前未排序序列最后一个元素时，新堆顶影响堆序，对它执行下滤方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//堆排序</span><br><span class="hljs-comment">//堆化方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> hole=(r<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;hole&gt;=<span class="hljs-number">0</span>;hole--)&#123;<br>        <span class="hljs-built_in">siftdown</span>(arr,hole,r);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//下滤方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">siftdown</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> hole,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-type">int</span> target=arr[hole],child =hole*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(child&lt;=r)&#123;<br>        <span class="hljs-comment">//满足child&lt;r则hole有右孩子，不满足则hole无右孩子，跳过</span><br>        <span class="hljs-comment">//满足第二个条件表示hole有右孩子并且右孩子大于左，使得child为更大的右孩子下标</span><br>        <span class="hljs-keyword">if</span>(child&lt;r&amp;&amp;arr[child+<span class="hljs-number">1</span>]&gt;arr[child]) child++;<br>        <span class="hljs-keyword">if</span>(arr[child]&gt;target)&#123;<br>            arr[hole]=arr[child];<br>            hole=child;<br>            child=hole*<span class="hljs-number">2</span>+<span class="hljs-number">1</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>    arr[hole]=target;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><h4 id="🚩快速排序"><a href="#🚩快速排序" class="headerlink" title="🚩快速排序"></a>🚩快速排序</h4><h5 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h5><p>快速排序由C.A.R.Hoare在1960年提出。在时间复杂度为$O(nlogn)$级别的几种排序算法中,大多数情况下效率更高，所以应用广泛。</p><p>它的基本思想是<strong>分治</strong>，确定<strong>主轴</strong>及<strong>分区</strong>是快速排序的核心，具体思路是</p><ol><li>从数组中取出一个数，称之为<strong>主轴或基数(pivot)</strong></li><li>遍历数组，使用<strong>分区方法</strong>，大于等于主轴的数字放到右边，小于主轴的数字放到左边。遍历完成后数组被分成了左右两个区域。</li><li>将左右两个区域视作两个数组，重复前两个步骤，直到排序完成</li></ol><p>主轴的选取有几种方式</p><ul><li><strong>主轴为起始元素</strong>（quickSortSimple）：即每次选取当前数组第一个元素作为主轴。<ul><li>优点：实现简单</li><li>缺点：如果输入是较为有序的数组，主轴不能均匀地分割数组。数组本身有序的极端情况下，复杂度退化到$O(n^2)$</li></ul></li><li><strong>主轴为随机下标元素</strong>（quickSortRandom）：即每次随机选取当前数组的下标，将该下标元素作为主轴<ul><li>优点：避免了较为有序数组不能均匀分割的情况</li><li>缺点：随机数算法本身耗费性能</li></ul></li><li><strong>主轴为左中右三数大小居中者</strong>（quickSortMedian3）：每次比较当前数组起始、中间和末尾三个元素的大小，选择大小居中者为主轴。<ul><li>优点：实现相对简单，且有效避免劣质分割</li><li>缺点：三数取中算法也消耗一定性能</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 三数取中方法 (将 arr[l], arr[c], arr[r] 三者居中者置于下标 l 处)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">median3</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> c = l + (r - l) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (arr[l] &gt; arr[c]) <span class="hljs-built_in">swap</span>(arr, l, c); <span class="hljs-comment">// 左中，大者居中</span><br>    <span class="hljs-keyword">if</span> (arr[c] &gt; arr[r]) <span class="hljs-built_in">swap</span>(arr, c, r); <span class="hljs-comment">// 中右，大者居右，此时最大者居右</span><br>    <span class="hljs-keyword">if</span> (arr[c] &gt; arr[l]) <span class="hljs-built_in">swap</span>(arr, l, c); <span class="hljs-comment">// 左中，大者居左，此时中者居左</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>快排中的核心方法是<strong>分区方法</strong>（partition）。分区方法执行后，主轴左边元素均小于主轴，主轴右边元素均大于等于主轴元素。分区方法返回主轴下标p</p><p>选定某数作为主轴后，都<strong>先将选定的主轴置于当前数组的起始位置<code>l</code></strong>，设置一个初始值为<code>j=l+1</code>的<code>j</code>，动态地寻找最终主轴下标。由左至右地将主轴后所有元素依次与主轴元素比较，如果小于主轴就将该数字与下标为<code>j</code>的数字交换，之后j右移一位，目标是使得j的前一位总是当前最后一个小于主轴的元素，遍历结束后交换下标为l的元素（即主轴）和下标为j-1的元素。此时主轴为j-1，返回j-1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; arr,<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> j=l+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=j;i&lt;=r;i++)&#123;<br>        <span class="hljs-keyword">if</span>(arr[i]&lt;arr[l])&#123;<br>            <span class="hljs-built_in">swap</span>(arr,i,j);<span class="hljs-comment">//交换后的arr[j]就是当前最后一个小于主轴的元素</span><br>            j++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">swap</span>(arr,l,j<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> j<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="递归单轴快排"><a href="#递归单轴快排" class="headerlink" title="递归单轴快排"></a>递归单轴快排</h5><p>在确定主轴位置后，递归地对主轴左右两侧执行排序过程。那么递归函数需要传入待排序序列arr和本次递归要处理的部分其左右界。当所有递归都到达基准情形是排序完成，因为是递归原地交换，递归过程无需返回，为<strong>尾递归</strong></p><blockquote><p>[!note]</p><p>尾递归是指一个函数在调用自身之后不再执行任何其他操作，而是将返回值直接传递给函数调用的上级</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//*****首位轴递归单轴快排*****//</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">quickSortSimple</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; arr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-built_in">quickSortSimpleRecursion</span>(arr,<span class="hljs-number">0</span>,arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-comment">//首位轴递归方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSortSimpleRecursion</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-comment">//left==right arr只有一个元素，完成递归</span><br>    <span class="hljs-keyword">if</span>(l&lt;r)&#123;<br>        <span class="hljs-comment">//获得主轴p</span><br>        <span class="hljs-type">int</span> p=<span class="hljs-built_in">partition</span>(arr,l,r);<br>        <span class="hljs-built_in">quickSortSimpleRecursion</span>(arr,l,p<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">quickSortSimpleRecursion</span>(arr,p+<span class="hljs-number">1</span>,r);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//************************//</span><br><span class="hljs-comment">//***三数取中轴递归单轴快排***//</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">quickSortMedian3</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; arr)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-built_in">quickSortSimpleMedian3</span>(arr,<span class="hljs-number">0</span>,arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-comment">//三数取中轴递归方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSortMedian3Rec</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-comment">//left==right arr只有一个元素，完成递归</span><br>    <span class="hljs-keyword">if</span>(l&lt;r)&#123;<br>        <span class="hljs-comment">//获得主轴p</span><br>        <span class="hljs-type">int</span> p=<span class="hljs-built_in">partition</span>(arr,l,r);<br>        <span class="hljs-built_in">quickSortSimpleMedian3Rec</span>(arr,l,p<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">quickSortSimpleMedian3Rec</span>(arr,p+<span class="hljs-number">1</span>,r);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//三数取中轴</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">median3</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> mid=l+(r-l)/<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//大小居中者为轴，即左边界left</span><br>    <span class="hljs-keyword">if</span>(arr[l]&gt;arr[mid]) <span class="hljs-built_in">swap</span>(arr,l,mid);<span class="hljs-comment">//使得l mid较大者居中</span><br>    <span class="hljs-keyword">if</span>(arr[mid]&gt;arr[r]) <span class="hljs-built_in">swap</span>(arr,mid,r);<span class="hljs-comment">//使得mid r较大者居右，此时r为最大</span><br>    <span class="hljs-keyword">if</span>(arr[mid]&gt;arr[l]) <span class="hljs-built_in">swap</span>(arr,l,mid);<span class="hljs-comment">//使得l mid较大者居左，此时l为中间数</span><br>&#125;<br><span class="hljs-comment">//**************************//</span><br><span class="hljs-comment">//*****随机轴递归单轴快排******//</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSortMedian3</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; arr,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-built_in">quickSortRandomRec</span>(arr,<span class="hljs-number">0</span>,arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-comment">//随机轴递归方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSortRandomRec</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l&lt;r)&#123;<br>        <span class="hljs-comment">//[l+1,r]随机数  [a,b]随机数(rand() % (b-a+1))+ a</span><br><span class="hljs-type">int</span> randID=(<span class="hljs-built_in">rand</span>()%(r-l))+l+<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">swap</span>(arr,l,randID);<br>        <span class="hljs-type">int</span> p=<span class="hljs-built_in">partition</span>(arr,l,r);<br>        <span class="hljs-built_in">quickSortRandomRec</span>(arr,l,p<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">quickSortRandomRec</span>(arr,p+<span class="hljs-number">1</span>,r);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//****************************//</span><br></code></pre></td></tr></table></figure><h5 id="非递归-栈迭代-单轴快排"><a href="#非递归-栈迭代-单轴快排" class="headerlink" title="非递归(栈迭代)单轴快排"></a>非递归(栈迭代)单轴快排</h5><p>递归方法思路直接，若要求不用递归形式实现快排，便可利用<strong>栈（LIFO）保存区间左右界</strong>。每次partition()方法划分确定主轴p后，将得到的p左右两侧区间的边界l、r压入栈中</p><ol><li>初始时左右界为[0，arr.size()-1]，将它们按r、l顺序入栈</li><li>while循环判断当前栈是否空，不空则弹出栈顶的一对边界（l、r顺序）<ol><li>若满足l&lt;r，则对当前这对l、r的区间继续执行partition()分区方法，得到该区间的主轴p</li><li>若满足l<p，则将p左侧区间的左右界压入栈(p-1、l顺序入栈)；若满足r>p则将p右侧区间的左右界压入栈(r、p+1)顺序</p，则将p左侧区间的左右界压入栈(p-1、l顺序入栈)；若满足r></li></ol></li><li>while结束时排序完成，返回arr</li></ol><h5 id="双轴快排"><a href="#双轴快排" class="headerlink" title="双轴快排"></a>双轴快排</h5><p>双轴快排是单轴快排的改进，需要<strong>注意细节</strong></p><p>之前的单轴快排每次递归地确定当前区间的主轴，并利用该主轴将当前区间再划分为两个部分。双轴快排则以<strong>两个轴</strong>（pivot1、pivot2）将当前区间划分为<strong>三个子区间</strong>。我们将$[left,pivot)$称作区间1，$(pivot1,pivot2)$称作区间2，$(pivot2,right]$称作区间3.</p><p>对于这三个区间有</p><ul><li>区间1：$arr[i]&lt;arr[p1],i∈[left,p1)$</li><li>区间2：$arr[p1]&lt;=arr[i]&lt;=arr[p2],i∈(p1,p2)$</li><li>区间3：$arr[i]&gt;arr[p2],i∈(p2,right]$</li></ul><p>对这三个子区间再执行划分区间的过程，直到无法划分时排序完成</p><p>具体过程如下</p><ol><li><p>dualPivotQuickSort执行开始，以left&lt;right为条件，<strong>只对大于等于2的区间执行双轴快排</strong></p></li><li><p><strong>令左右两端元素中较小者居左</strong>，之后以left为p1初始的下标，right为p2初始的下标，保证p1&lt;p2。</p></li><li><p>设置index=left+1，lower=left+1，upper=right-1。</p><ul><li>index表示当前考察的元素下标。</li><li>lower是动态向右扩展的下标，用来推进到p1最终位置。<strong>任意时刻[left,lower)中的元素总确定在区间1中</strong>。</li><li>upper是动态向左扩展的下标，用来推进到p2最终位置。<strong>任意时刻(upper,right]中的元素总确定在区间3中</strong>。</li><li>初始时，lower==left+1，upper==right-1，表示left和right实际上分别在区间1和2中，但lower和upper本身不在区间1和2中；当循环结束时，lower—和upper++就是主轴最终p1和p2的位置。</li></ul></li><li><p>while循环遍历从lower（即left+1）到upper（即right-1）的所有元素，通过每个元素与arr[left]左轴值和arr[right]右轴值的比较、交换，将每个元素正确地置于区间1（<arr[p1]）、区间2（arr[p1]<=arr[index]<=arr[p2]）和区间三中（>arr[p2]）<br>与此同时，lower动态右移，upper动态左移，对这三个区间进行动态调整，index++，遍历所有元素。亦即在单个循环内：</arr[p1]）、区间2（arr[p1]<=arr[index]<=arr[p2]）和区间三中（></p><ol><li><p>循环边界是(index&lt;=upper)，因为就算三个区间动态调整，但是upper右边（不含upper）的元素是确定在区间3（即大于arr[p2]）的。那么index向右不能超过upper，而upper本身不一定。故是index&lt;=upper。</p></li><li><p>首先考察arr[index]是否在区间1，若在区间1将该元素至于lower右侧，区间1向右扩展。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(arr[index]&lt;arr[left])&#123;<br><span class="hljs-built_in">swap</span>(arr,index,lower);<br>lower++;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>若不在区间1，检查是否在区间3，若满足则在区间3。此时将该元素置于upper右侧，且区间3向左扩展。</p><blockquote><p>[!note]</p><p>不同于2. 直接交换arr[index]和arr[lower]，2.中因为尽管lower在交换前不一定在区间1中，但是index是不断向左移动的，最后一定能判断到与原lower交换位置后与arr[left]的关系。而对于3.来说，如果还像2.一样直接交换，无法判断换到区间2的原upper与arr[right]的关系，因为index是不断向左移动的。</p></blockquote><p>所以在交换之前应该实现一种操作，使得与arr[index]交换的arr[upper]确定是哪个区间的元素。首先确定是不是区间3中的元素。于是可以先从当前arr[upper]向左考察是否有arr[upper]&gt;arr[right]，若有则表示arr[upper]在区间3，直接upper—左扩跳过。直到不满足时表示此时arr[upper]确定不是区间3，准备交换。注意左扩不能扩到现在的index，要保证循环边界有效。<br>此时还不能确定该元素在区间1还是区间2中，对其再执行一次4.2.相同的步骤</p><p>上述完成了对arr[index]的检查和处理，此时index++，检查处理下一个元素。</p></li></ol></li><li><p>当while(index&lt;=upper)结束时，所有元素检查处理完毕。此时最后一个确定在区间1的元素下标是lower—，最后一个确定在区间3的元素下标是upper++。将其分别与左右轴p1和p2交换，使得左右轴归位，排序结束。</p></li></ol><p><img src="/2023/02/20/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/1652692972-TbEiju-image.png" alt="image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *     区间1               区间2                         区间3</span><br><span class="hljs-comment"> * +------------------------------------------------------------+</span><br><span class="hljs-comment"> * |  &lt; pivot1  | pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    | &gt; pivot2  |</span><br><span class="hljs-comment"> * +------------------------------------------------------------+</span><br><span class="hljs-comment"> *              ^                         ^         ^</span><br><span class="hljs-comment"> *              |                         |         |</span><br><span class="hljs-comment"> *            lower                     index      upper</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dualPivotQuickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br><span class="hljs-keyword">if</span>(left&lt;right)&#123;<br><span class="hljs-keyword">if</span>(arr[left]&gt;arr[right])&#123;<br><span class="hljs-built_in">swap</span>(arr,left,right);<br>&#125;<br><br>        <span class="hljs-type">int</span> index=left+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> lower=left+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> upper=right<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(index&lt;=upper)&#123;<br>            <span class="hljs-keyword">if</span>(arr[index]&lt;arr[left])&#123;<br>                <span class="hljs-built_in">swap</span>(arr,index,lower);<br>                lower++<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>&#123;<br>                <span class="hljs-keyword">while</span>(arr[upper]&gt;arr[right]&amp;&amp;index&lt;upper)&#123;<br>                    upper--;<br>                &#125;<br>                <span class="hljs-built_in">swap</span>(arr,index,upper);<br>                upper--;<br>                <span class="hljs-keyword">if</span>(arr[index]&lt;arr[left])&#123;<br>                    <span class="hljs-built_in">swap</span>(arr,index,lower);<br>                    lower++;<br>                &#125;<br>            &#125;<br>            index++<br>        &#125;<br>        <span class="hljs-comment">//lower--;upper++;</span><br>        <span class="hljs-built_in">swap</span>(arr,left,--lower);<br>        <span class="hljs-built_in">swap</span>(arr,++upper,right);<br>        <span class="hljs-built_in">dualPivotQuickSort</span>(arr,left,lower<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">dualPivotQuickSort</span>(arr,lower+<span class="hljs-number">1</span>,upper<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">dualPivotQuickSort</span>(arr,upper+<span class="hljs-number">1</span>,right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><h4 id="🚩归并排序"><a href="#🚩归并排序" class="headerlink" title="🚩归并排序"></a>🚩归并排序</h4><h5 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h5><p>将原待排序数组<strong>递归或迭代</strong>地分为左右两半，直到数组长度为1，然后合并左右数组，在合并中完成排序。将问题转化为两个有序数组的合并。<br>我们发现在第二个列表向第一个列表逐个插入的过程中，由于第二个列表已经有序，所以<strong>后续插入的元素一定不会在前面插入的元素之前</strong>，那么这样一来我们最多只需要将两个有序数组遍历一次（而不是两次）就能完成合并。<br>我们可以开辟一个新数组，使用两个指针来遍历原有的两个数组不断地将较小的数字添加到新数组中。</p><p>简单来说</p><ol><li>将序列中待排序数字分为若干组，每个数字为一组。</li><li>将若干个组两两合并，保证合并后的组是有序的。</li><li>重复第二步直到剩下一组。</li></ol><p>可以通过<strong>自顶向下(top-down)</strong>或<strong>自底向上(bottom-up)</strong>的方式实现归并排序。</p><p>自顶向下 (top-down)：从输入数组出发，不断二分该数组，直到数组长度为1，再执行合并。适合用<strong>递归</strong>实现。</p><p>自底向上 (bottom-up)：从输入数组的单个元素出发，一一合并，二二合并，四四合并直到数组有序。适合用<strong>迭代</strong>实现。</p><h5 id="原地归并"><a href="#原地归并" class="headerlink" title="原地归并"></a>原地归并</h5><p>除了使用前面临时数组，我们还可以使用<strong>原地旋转交换（或称手摇算法、内存反转算法、三重反转算法，block swap algorithm）</strong>使得其辅助空间为$O(1)$ （但是递归空间为$O(logn)$ 所以总的复杂度仍为$O(logn)$）</p><p>以456123为例，欲将456和123交换位置转换为123456，需要</p><ol><li>旋转456，得到654【654123】</li><li>旋转123，得到321【654321】</li><li>旋转654321得到123456</li></ol><p>应用原地旋转交换的原地归并，过程如下</p><ol><li><p>记<strong>左数组</strong>第一个元素下标为i，记右数组第一个数下标为j。</p></li><li><p>i向后遍历，找到左数组中第一个<strong>大于</strong>右数组第一个数字（即arr[j]）的数，此时有arr[i]&gt;arr[j]。</p></li><li><p>以index暂存<strong>右数组</strong>第一个元素的下标，即index=j</p></li><li><p>找到右数组中第一个<strong>大于等于</strong>arr[i]的数，记其下标为j。此时必有[i,index-1]下标范围序列<strong>大于</strong>[index，j-1]下标范围序列</p></li><li><p>通过三次反转交换[i,index-1]和[index，j-1]序列，即依次反转[i,index-1]、反转[index，j-1]、反转[i，j-1]</p></li><li><p>重复上述过程直到<code>(i&lt;j&amp;&amp;j&lt;=r)</code></p><p>注意第四步找的是右数组第一个<strong>大于等于</strong>arr[i]的数，如果找严格大于将破坏稳定性</p></li></ol><p>我们以{1，2，4，6，7}和{3，5，8，9}两个已排序的序列为例，演示原地归并</p><ol><li>在{1，2，4，6，7}中找到一个大于3的数4，其下标为i=2，那么右数组第一个元素的下标为index=j=5。在{3，5，8，9}中找到第一个大于arr[i]=arr[2]=4的数5，其下标为6，j=6。</li><li>这样使得[0,i-1]必然是最小序列，[index，j-1]必然小于arr[i]，而后大于[0，i-1]。因此交换[i，index-1]和[index，j-1]使得这部分在数组中有序。</li><li>交换后，继续执行上述过程直到<code>i&lt;j&amp;&amp;j&lt;=r</code>。</li></ol><p><img src="/2023/02/20/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/1652692350-OvThvJ-image.png" alt></p><p><img src="/2023/02/20/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/FILE\myBlog\Hexo_Blog\source\_posts\leetbook笔记（三）排序专题\image-20240307170206066-1709802127443-3.png" alt="image-20240307170206066"></p><p>根据上述分析，原地相比非原地，空间消耗较少，采用 自底向上原地归并排序 时空间复杂度为常数级 O(1)，但需要O(n^2)的时间复杂度。是一种以时间换空间的做法，通常空间不为瓶颈时，应采用 效率更高的非原地归并排序。</p><h5 id="自顶向下（递归）非原地归并"><a href="#自顶向下（递归）非原地归并" class="headerlink" title="自顶向下（递归）非原地归并"></a>自顶向下（递归）非原地归并</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] <span class="hljs-built_in">mergeSort</span>(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-keyword">if</span> (arr.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-type">int</span>[] tmpArr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[arr.length];<br>    <span class="hljs-built_in">mergeSort</span>(arr, tmpArr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-comment">// mergeSort 递归方法</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span>[] tmpArr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l &lt; r) &#123;<br>        <span class="hljs-type">int</span> c = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">mergeSort</span>(arr, tmpArr, l, c);<br>        <span class="hljs-built_in">mergeSort</span>(arr, tmpArr, c + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-built_in">merge</span>(arr, tmpArr, l, c, r);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 非原地合并方法</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span>[] tmpArr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> lh = l, rh = c + <span class="hljs-number">1</span>, h = l; <span class="hljs-comment">// lh: left head, rh: right head, h: tmpArr head</span><br>    <span class="hljs-keyword">while</span> (lh &lt;= c &amp;&amp; rh &lt;= r) &#123;<br>        tmpArr[h++] = arr[lh] &lt;= arr[rh] ? arr[lh++] : arr[rh++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (lh &lt;= c) tmpArr[h++] = arr[lh++]; <span class="hljs-comment">// 左半边还有剩余，加入 tmpArr 末尾</span><br>    <span class="hljs-keyword">while</span> (rh &lt;= r) tmpArr[h++] = arr[rh++]; <span class="hljs-comment">// 右半边还有剩余，加入 tmpArr 末尾</span><br>    <span class="hljs-keyword">for</span>(; l &lt;= r; l++) arr[l] = tmpArr[l]; <span class="hljs-comment">// 将 tmpArr 拷回 arr 中</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度O-n-级别排序"><a href="#时间复杂度O-n-级别排序" class="headerlink" title="时间复杂度O(n)级别排序"></a>时间复杂度O(n)级别排序</h3><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>快速排序</tag>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetbook算法笔记（二）链表、队列和栈</title>
    <link href="/2023/02/18/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E9%93%BE%E8%A1%A8%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/"/>
    <url>/2023/02/18/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E9%93%BE%E8%A1%A8%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li><p>单链表的每个结点不仅包含值，还包含到下一个结点的引用字段</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//单链表中结点的典型定义 C++ style</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SinglyListNode</span>&#123;<br>    <span class="hljs-type">int</span> val;<br>    SinglyListNode *next;<br>    <span class="hljs-comment">//构造函数冒号后直接接初始化参数</span><br>    <span class="hljs-built_in">SinglyListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-comment">//C style</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">List</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">List</span> *next;<br>&#125;List, *LIST;<span class="hljs-comment">//struct List =&gt; List *xxx ||struct List*=&gt; LIST xxx</span><br></code></pre></td></tr></table></figure></li><li><p>与数组不同，我们无法在常量时间内访问单链表中的随机元素，必须从头结点开始逐个遍历。即为花费O(N)时间。</p></li></ul><h4 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h4><ul><li>最简单一句话思路：<strong>先让新来的结点有所指向</strong><ul><li><img src="/2023/02/18/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E9%93%BE%E8%A1%A8%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/image-20240118100036608.png" alt></li></ul></li><li><p>我们用头结点代表整个链表，在开头添加结点须要：</p><ol><li>初始化新结点cur</li><li>新结点连接到原始头结点head</li><li>将cur指定为head</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//中间插入结点</span><br>singlyListNode cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">singlyListNode</span>(val,next);<br>cur.Next=prev.next;<br>prev.next=cur;<br><span class="hljs-comment">//开头添加结点</span><br>singlyListNode cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">singlyListNode</span>(val,next);<br>cur.next=head;<br>head=cur;<br><span class="hljs-comment">//结尾添加结点</span><br><span class="hljs-keyword">while</span>(cur.next!=null)&#123;<br>    cur=cur.next;<br>&#125;<br>cur.next=newNode;<br></code></pre></td></tr></table></figure></li></ul><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><ul><li>删除中间结点<ol><li>找到cur的上一个结点prev及其下一个结点next</li><li>连接prev到cur的下一个结点next</li></ol></li><li><p>删除第一结点</p><ol><li>直接将下一个结点分配为head结点</li></ol></li><li><p>删除最后结点</p><ol><li>置倒数第二个结点的后继指针为空</li></ol></li></ul><h4 id="链表中的双指针"><a href="#链表中的双指针" class="headerlink" title="链表中的双指针"></a>链表中的双指针</h4><ul><li><p>快慢指针判断是否有环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Initialize slow &amp; fast pointers</span><br>ListNode* slow = head;<br>ListNode* fast = head;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Change this condition to fit specific problem.</span><br><span class="hljs-comment"> * Attention: remember to avoid null-pointer error</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">while</span> (slow &amp;&amp; fast &amp;&amp; fast-&gt;next) &#123;<br>    slow = slow-&gt;next;          <span class="hljs-comment">// move slow pointer one step each time</span><br>    fast = fast-&gt;next-&gt;next;    <span class="hljs-comment">// move fast pointer two steps each time</span><br>    <span class="hljs-keyword">if</span> (slow == fast) &#123;         <span class="hljs-comment">// change this condition to fit specific problem</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">// change return value to fit specific problem</span><br></code></pre></td></tr></table></figure></li><li><p>D=(N-1)(S1+S2)+S2</p></li><li><p>首次相遇后，慢指针不动。将快指针倒回首结点，和慢指针同速，再相遇即为入环点</p></li></ul><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><ul><li><p>方案一：按原始顺序迭代结点，并将它们逐个移动到列表头部</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)&#123;<br>        prev-&gt;next = cur-&gt;next;<br>        cur-&gt;next = dummy-&gt;next;<br>        dummy-&gt;next = cur;<br>        cur = prev-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy-&gt;next;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><h2 id="队列与栈"><a href="#队列与栈" class="headerlink" title="队列与栈"></a>队列与栈</h2><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li><p>队列是先入先出（FIFO）的数据结构，插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。 删除（delete）操作也被称为出队（dequeue)。 只能移除第一个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">//队列应支持两种操作，入队和出队，需要一个索引指出起点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-comment">// 数据域</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; data;       <br>        <span class="hljs-comment">// 起点</span><br>        <span class="hljs-type">int</span> p_start;            <br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">MyQueue</span>() &#123;p_start = <span class="hljs-number">0</span>;&#125;<br>        <span class="hljs-comment">//先入先出，入队时起点不变</span><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>            data.<span class="hljs-built_in">push_back</span>(x);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//出队时，先入先出，即起点后移</span><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            p_start++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;;<br>        <span class="hljs-comment">//得到起点</span><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Front</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> data[p_start];<br>        &#125;;<br>        <span class="hljs-comment">//检查队列是否空</span><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span>  </span>&#123;<br>            <span class="hljs-keyword">return</span> p_start &gt;= data.<span class="hljs-built_in">size</span>();<br>        &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyQueue q;<br>    q.<span class="hljs-built_in">enQueue</span>(<span class="hljs-number">5</span>);<br>    q.<span class="hljs-built_in">enQueue</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>        cout &lt;&lt; q.<span class="hljs-built_in">Front</span>() &lt;&lt; endl;<br>    &#125;<br>    q.<span class="hljs-built_in">deQueue</span>();<br>    <span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>        cout &lt;&lt; q.<span class="hljs-built_in">Front</span>() &lt;&lt; endl;<br>    &#125;<br>    q.<span class="hljs-built_in">deQueue</span>();<br>    <span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>        cout &lt;&lt; q.<span class="hljs-built_in">Front</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//随着出队即起始指针的移动，浪费了越来越多的空间。 当我们有空间限制时，这将是难以接受的。这就需要循环队列。</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCircularQueue</span> &#123;<br>    <span class="hljs-comment">//一队头索引，一队尾索引</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; data;<br>    <span class="hljs-type">int</span> p_start;<br>    <span class="hljs-type">int</span> p_last;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyCircularQueue</span>(<span class="hljs-type">int</span> k) &#123;<br>        data.<span class="hljs-built_in">resize</span>(k);<br>        <span class="hljs-comment">//队列为空状态</span><br>        p_start=<span class="hljs-number">-1</span>;<br>        p_last=<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">//入队，先入先出，队头不变，队尾+1</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) &#123;<br>            p_start++;<br>            p_last++;<br>            data[p_last] = value;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isFull</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//通过+1和队列长度求余数，来循环。关键一步。</span><br>        p_last = (p_last + <span class="hljs-number">1</span>) % data.<span class="hljs-built_in">size</span>();<br>        data[p_last] = value;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//出队，先入先出，队头+1队尾不变</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (p_start == p_last) &#123;<br>            p_start = <span class="hljs-number">-1</span>;<br>            p_last = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        p_start = (p_start + <span class="hljs-number">1</span>) % data.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> data[p_start];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Rear</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> data[p_last];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (p_start == <span class="hljs-number">-1</span> &amp;&amp; p_last == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> ((p_last + <span class="hljs-number">1</span>) % data.<span class="hljs-built_in">size</span>() == p_start) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="队列与广度优先搜索"><a href="#队列与广度优先搜索" class="headerlink" title="队列与广度优先搜索"></a>队列与广度优先搜索</h4><p>  BFS通过队列实现，关于树的层序遍历见 树-树的遍历-层序遍历。更多可见广度优先搜索专题。</p><h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li><p>栈是后入先出（LIFO）的数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//可用可变数组实现堆栈结构 could use variable-array </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; data; <span class="hljs-comment">//store elements</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 常用函数 判空 判顶 压栈 出栈</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">back</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>        data.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isEmpty</span>())&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        data.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h4 id="栈与深度优先搜索"><a href="#栈与深度优先搜索" class="headerlink" title="栈与深度优先搜索"></a>栈与深度优先搜索</h4><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>队列</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetbook算法笔记（一）程序模拟、数组和字符串</title>
    <link href="/2023/02/15/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%20/"/>
    <url>/2023/02/15/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%20/</url>
    
    <content type="html"><![CDATA[<h2 id="程序模拟"><a href="#程序模拟" class="headerlink" title="程序模拟"></a>程序模拟</h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>模拟就是用计算机来模拟题目中要求的操作。</p><p>模拟题目通常具有码量大、操作多、思路繁复的特点。由于它码量大，经常会出现难以查错的情况，如果在考试中写错是相当浪费时间的。</p><p>写模拟题时，遵循以下的建议有可能会提升做题速度：</p><ul><li>在动手写代码之前，在草纸上尽可能地写好要实现的<strong>流程</strong>。</li><li>在代码中，尽量把<strong>每个部分模块化</strong>，写成函数、结构体或类。</li><li>对于一些可能重复用到的概念，可以统一转化，方便处理：如，某题给你 “YY-MM-DD 时：分” 把它抽取到一个函数，处理成秒，会减少概念混淆。</li><li>调试时分块调试。模块化的好处就是可以方便的单独调某一部分。</li><li>写代码的时候一定要<strong>思路清晰</strong>，不要想到什么写什么，要按照落在纸上的步骤写。</li></ul><p>实际上，上述步骤在解决其它类型的题目时也是很有帮助的。</p><h2 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>读取<ul><li>时间复杂度O(1)</li><li>直接访问索引，取值</li></ul></li><li>查找<ul><li>时间复杂度O(N)</li><li>逐步读取，逐步比较，相同则取出</li></ul></li><li>插入<ul><li>索引，后移腾空，插入</li></ul></li><li>删除<ul><li>索引，删除，向前填补</li></ul></li></ul><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><ul><li>二维数组存储空间<strong>连续</strong> </li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li>比较</li><li>连接</li></ul><h4 id="字符串匹配算法KMP"><a href="#字符串匹配算法KMP" class="headerlink" title="字符串匹配算法KMP"></a>字符串匹配算法KMP</h4><ul><li>目标：在一个字符串中匹配一个子串</li><li><p>时间复杂度O(m+n)</p></li><li><p>关键思路：在信息不匹配的时候，由于已经遍历过主串部分字符，可利用这些信息避免主串指针回退。换句话说，不递减主串的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">match</span> <span class="hljs-params">(<span class="hljs-type">char</span>* P, <span class="hljs-type">char</span>* S)</span></span>&#123; <span class="hljs-comment">// KMP 算法</span><br>    <span class="hljs-type">int</span>* next = <span class="hljs-built_in">buildNext</span>(P); <span class="hljs-comment">// 构造 next 表</span><br>    <span class="hljs-type">int</span> m = (<span class="hljs-type">int</span>) <span class="hljs-built_in">strlen</span>(S), i = <span class="hljs-number">0</span>; <span class="hljs-comment">// 文本串指针</span><br>    <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>) <span class="hljs-built_in">strlen</span>(P), j = <span class="hljs-number">0</span>; <span class="hljs-comment">//模式串指针</span><br>    <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; i &lt; m) <span class="hljs-comment">// 自左向右逐个比对字符</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &gt; j || S[i] == P[j]) <span class="hljs-comment">// 若匹配，或 P 已移除最左侧</span><br>            &#123;i++; j++;&#125; <span class="hljs-comment">// 则转到下一字符</span><br>        <span class="hljs-keyword">else</span><br>            j = next[j]; <span class="hljs-comment">// 模式串右移（注意：文本串不用回退）</span><br>    <span class="hljs-keyword">delete</span> [] next; <span class="hljs-comment">// 释放 next 表</span><br>    <span class="hljs-keyword">return</span> i - j;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>关键问题：再比对时，怎么知道要跳过多少字符呢</p><ul><li><p>通过next数组，最后一个匹配的字符所对应的next数值即为子串中跳过匹配字符的个数</p></li><li><p>next数组本质是记录子串共同前后缀的长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs 伪代码">//buildNext<br>while(i小于数组长度)&#123;<br>if (共同前后缀最后字符==该字符)&#123;<br>共同前后缀长度+=1;<br>next数组追加(共同前后缀长度);<br>i+=1;<br>&#125;else&#123;<br>if(共同前后缀长度==0)&#123;<br>next数组追加(0);<br>i+=1;<br>&#125;else&#123;<br>//减小前后缀长度查看存不存在更短的前后缀<br>共同前后缀长度 = next[共同前后缀长度-1]<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="双指针思想"><a href="#双指针思想" class="headerlink" title="双指针思想"></a>双指针思想</h3><h4 id="始末指针"><a href="#始末指针" class="headerlink" title="始末指针"></a>始末指针</h4><ul><li>使用始末指针的典型场景，是要从两端向中间迭代数组</li><li>退出条件一般是头指针&lt;尾指针</li></ul><h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><ul><li>两指针不同步，即为快指针无条件移动，慢指针有条件移动，或快指针移动条件松于慢指针。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《The Rendering Equation》简译</title>
    <link href="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/"/>
    <url>/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<div class="admonition info"><p class="admonition-title">信息  </p><p>这是一篇经典论文，在其思想深刻影响后世的同时，部分表述已不再流行。</p></div><div class="admonition attention"><p class="admonition-title">注意  </p><p>因水平有限，本翻译部分参考机翻。并只进行了简单校对，未有精校，或有错译现象。此文本仅供参考。</p></div><h1 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h1><h5 id="SIGGRAPH-1986-1986-4"><a href="#SIGGRAPH-1986-1986-4" class="headerlink" title="SIGGRAPH 1986(1986.4)"></a>SIGGRAPH 1986(1986.4)</h5><h5 id="James-T-Kajiya"><a href="#James-T-Kajiya" class="headerlink" title="James T. Kajiya"></a>James T. Kajiya</h5><h5 id="加州理工学院"><a href="#加州理工学院" class="headerlink" title="加州理工学院"></a>加州理工学院</h5><p><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/THE%20RENDERING%20EQUATION0001.png" alt="ACM SIGGRAPH Computer Graphics, Volume 20, Issue 4, Aug. 1986, pp. 143–150, https://doi.org/10.1145/15886.15902, Title:The Rendering Equation"></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>我们提出了一个集已知的渲染算法之大成的积分方程。在讨论用蒙特卡洛法解决此问题时，我们也提出了一种新的样本方差减少方法，其称为“分层采样法”，并给出了有关此方法的详细阐述。由此产生的渲染算法扩展了可以有效模拟的光学现象的范围。</p><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>计算机图形学，光栅化，光线追踪，辐射度量学，蒙特卡洛法，分布式光线追踪，方差消减。</p><h2 id="渲染方程-1"><a href="#渲染方程-1" class="headerlink" title="渲染方程"></a>渲染方程</h2><p>我们提出的技术涵盖了各种各样的渲染算法，并提供了一个统一的研究背景，以便于可以将之前各式的算法视作这一方程的各种近似。一旦意识到所有的渲染方法都试图模拟相同的物理现象，即光在各种表面散射（译注：此处及下文的散射是广义的，反射和折射都是弹性散射。不过未经专门说明，将这些”散射”理解为漫反射是更简单的方法）的现象，就不会对形形色色的渲染方法能归于一式感到惊讶了。  </p><p>对我们所提的渲染方程，其背后的想法已不新鲜。对这个方程所模拟的现象的描述，在辐射传导领域中已经研究了数年[Siegel , Howell 1981]。然而，我们提出的这个很适合于计算机图形学的方程形式，在以前却未出现过。  </p><p>渲染方程为<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/渲染方程.png" alt="渲染方程"><br>其中：I(x, x’)  约束了从x’到x点的辐射强度<br>g(x, x’)  是几何分量<br>e(x, x’)  约束了从x’到x点的自发光强度<br>ρ(x, x’,x’’)  约束了一定表面上散射光的强度</p><p>这个方程非常符合辐射度量学方程的精神，只是简洁地平衡了从单一表面的一个点到另一个点的能量。该方程指出，从一个点到另一个点的光的传输强度只是自发光和从所有其他表面点散射到该点的总的光强度之和。方程(1)与辐射度量学方程的不同之处在于，没有对相关表面的反射特性作出假设。  </p><p>对方程中每一个量，我们都暂称为“非闭合的多重传输量”。我们将在第二节逐个给出定义并将其与·辐射度量学联系起来。 </p><p>该积分的积分域是在所有几何表面上，因此点x、x’、x’’的范围也是在此域中。不仅如此，还有定义了背景表面S0，其是一个足够大的半球，能够作为整个模型完全的包围圈。需要指出的是，该包围半球的正半球涵盖光线可能的所有反射域，负半球涵盖了光线可能的所有传输域。</p><p>作为麦克斯韦电磁方程的一个近似模拟，(1)并没有模拟所有有趣的光学现象。(1)并不试图对所有光学现象进行建模，它基本上是一个几何光学近似。我们只建立了时间平均传输强度的模型，因此在这个方程中没有考虑到辐射相位————即排除了对衍射的任何处理。我们还假设了不同介质表面之间是均匀的折射率，并且本身不参与散射光。后两种情况可以通过公式(1)的成对归纳来处理，在第一种情况下，只需让g(x, x’)考虑到具有非均质折射率的介质以处理光程。对于参与传播的介<br>质，需要一个整数微分方程。其拓展延伸也是众所周知的，见[Chandraseka.r 1950]，以及用于计算机图形应用的[Kajiya and von Herzen 1984]。处理不同介质光程的合理方式，哈密顿-雅可比方程[Goldstein 1950]，至少在一个世纪前就有了，对参与介质以及相位和衍射的处理可以被其处理。关于这些与各种物理现象有关的光学拓展方法，见[Feynman and Hibbs 1965]。最后，公式(1)中确实没有提到波长或偏振的相关性质。而考虑波长和偏振却是理所应当的。  </p><h2 id="对传输量的论述"><a href="#对传输量的论述" class="headerlink" title="对传输量的论述"></a>对传输量的论述</h2><p>在此我们讨论方程（1）的每个物理量和数学项。<br>这个方程描述了一个简化模型的光线传输过程。我们将把I(x,x’)命名为从x’到x的非闭合的两点辐射强度，或者更简洁地称其为辐射强度。辐射强度I( x, x’) 是单位时间单位区域dx’向dx的辐射能量。<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/2.png" alt="辐射强度"><br>I的单位是瓦特每球面度每平方米。  </p><p>数学量g(x, x’) 是一个几何项，这个项对表面点被其他表面点遮挡的情况进行标记。如果在场景中，x’和x实际上不是相互可见的，那么这个几何项就是0。另一方面，如果它们彼此可见，那么这个项就是1/r2，其中r是x’到x的距离。注意到，一个闭合的完全透明的表面可以使g(x, x’)等于0。因为事实上，透明的表面截留了辐射的反射能量，并将其重新折射到另一边。  </p><p>自发光项e(x, x’)，其测量的是发出于x’点到达x点的能量。我们称其为“非闭合的自发光转移量”。它给定了单位时间单位面积的光源到达目标单位面积的能量，亦即：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/3.png" alt="自发光项e"><br>其单位为瓦特每平方米。 </p><p>最后，辐射率ρ(x, x’, x”)是由x’处的表面辐射出的能量强度，从x”方向的入射光线开始，到x方向的出射光线结束。我们将称它为“从x “到x’处的非闭合的辐射率”。所以到达x的能量是：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/4.png" alt="辐射率"><br>其单位为瓦特每球面度每平方米。  </p><p>现在我们把传输量与更常规的辐射度量学联系起来。我们将通过在给定的数学几何模型中，论述能量传输模型中的每个量来实现这一点。 </p><p>通用辐射度量模型中的辐射强度（译注：光学上称发光强度）定义为每单位时间每单位投射面积的能量，即：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/5.png" alt="辐射能量_度量学">  </p><p>由几何模型可知：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/6.png" alt="立体角推导"><br>其中：向量n是表面dx的法向量<br>向量n’是表面dx’的法向量<br>向量t’是表面dx’的切向量<br>标量r 是x’ 到x 的距离  </p><p>一个表面项dx所对应的立体角是半径为r的球体被dx的球面投影面积dxp所占据的面积。即：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/7.png" alt="立体角公式">  </p><p>那么，将公式(7)带入到公式(5)能够得到：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/8.png" alt="辐射能量_立体角">   </p><p>公式(2)和公式(5)的比较能给出我们定义的辐射强度这一传输量和通用辐射度量学的关系：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/9.png" alt="辐射强度_度量学">  </p><p>自发光项与通用辐射度量学的关系也是这样得到的。假设有非闭合的表面，从dx’到dx的自发光分量，由公式(3)定义。通过如上引入立体角的流程，我们可以得到：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/10.png" alt="自发光_度量学">  </p><p>最后，我们将传输量中的反射率与通用辐射度量学中的双向反射函数ρ(θ’, φ’, ψ’, σ’)联系起来，从定义来看：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/11.png" alt="BRF">  </p><p>我们除了能得到方程(6)和(7)外，还可得到以下内容：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/12.png" alt="BRF_几何量"><br>其中：<br>向量n’’ 是表面dx’’的法线向量<br>标量r’’ 是x’’到x’的距离<br>dω’’为基于dx’’的立体角<br>结合公式(2)、(8)、(9)、(11)和(12)，我们可以得到非闭合的考虑三点的双向反射函数定义：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/13.png" alt="BRF_定义">  </p><h2 id="诸近似求解法"><a href="#诸近似求解法" class="headerlink" title="诸近似求解法"></a>诸近似求解法</h2><p>在本节中，我们将回顾渲染方程的近似解法。这些近似解法表明，各种渲染算法都可以在这个渲染方程提供的统一背景下进行研究。在讨论的过程中，读者可能会想到许多其他未曾尝试过的近似解法。我们鼓励研究者在这个领域开展更多的工作。这个领域在很大程度上还未被探索，因为目前的大部分努力只集中在下面要介绍的诸解决方法上。  </p><h3 id="诺伊曼级数"><a href="#诺伊曼级数" class="headerlink" title="诺伊曼级数"></a>诺伊曼级数</h3><p>解决像公式(1)这样的积分方程的一种方法来自一个众所周知的形式化操作，见[Courant and Hilbert 1953]。我们可将其改写为如下形式:<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/Neumann_a.png" alt="诺伊曼_a"><br>其中M是由公式(l)中的积分所给出的线性算子。现在，我们可把这个方程改写为：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/Neumann_b.png" alt="诺伊曼_b"><br>其中1是单位算子，由此我们可以通过以下方式形式地反转该等式：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/Neumann_c.png" alt="诺伊曼_c"><br>该无限级数收敛的一个条件是算子M的谱半径小于1。(在我们讨论的情况下，这一点是可以满足的）。对诺伊曼级数展开的物理解释同样吸引我们。它描述了辐射传输模型的辐射强度实质上是直接光照项、一次散射项、二次散射项、与以此类推的多次散射项之和。  </p><h3 id="犹他近似"><a href="#犹他近似" class="headerlink" title="犹他近似"></a>犹他近似</h3><p>由于缺乏更好的说法，我们将直接把渲染着色表面的经典方法称为犹他近似法（译注：实际上这是后世所称Blinn-Phong经验模型的数学物理依据）。在这种近似法中我们直接用两项之和来近似辐射强度I：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/utah.png" alt="犹他近似"><br>能看到，犹他近似法忽略除了一次散射外所有的散射，到目前为止，几何项成为最难计算的项。Utah近似法只对最终散射进入眼睛的g项进行计算。当然，这就成为由犹他大学的许多早期研究人员研究的经典的隐藏面问题。请注意，在第二项中，算子M不在ge上操作，而是在直接影响e0。因此，这个近似值忽略了自发光的可见性，亦即忽略了阴影。e0项意味着只考虑单一点光源。没有考虑扩展的其他照明表面。这种简化将算子M简化为对点光源的一个有限规模的求和，而不是对整个投射光域x’’的积分。  </p><p>从那时起，出现了许多拓展算法，最引人注目的是阴影处理算法和扩展光源种类的工作。  </p><h3 id="光线追踪算法"><a href="#光线追踪算法" class="headerlink" title="光线追踪算法"></a>光线追踪算法</h3><p>Whitted[1980]，提出了一个不同于前的近似方法：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/whitted.png" alt="光线追踪"><br>在这一著名的近似中， M0是一个散射模型，它是两个delta函数和一余弦项的总和。这两个delta函数代表了他照明模型中的反射和折射，余弦项代表漫反射成分。应注意，他考虑到了ge0亦即阴影，但仍然是处于点光源下的情况。Whitted的环境光项直接来自e项。 同样的，算子M是一个有限规模求和。  </p><h3 id="随机光线追踪算法"><a href="#随机光线追踪算法" class="headerlink" title="随机光线追踪算法"></a>随机光线追踪算法</h3><p>1984年，Cook[Cook et al 1984]，引入了随机光线追踪算法。这种近似方法是了具有三部分的Whitted模型的扩展，从而产生了一个更精确的散射模型。这一扩展使得在计算算子M时，对积分的估值变得必要。在这个模型中，M是由反射和折射delta函数的分布估值来近似表示的。使之成为可能的创新是使用蒙特卡洛法来进行积分数值估计。众所周知，估计积分数值的能力广泛地扩展了可被分析的光学现象其范围。<br>然而，对于随机光线追踪来说，对环境光项的适当处理仍然难以实现。  </p><h3 id="辐射度方法"><a href="#辐射度方法" class="headerlink" title="辐射度方法"></a>辐射度方法</h3><p>1984年，Cohen md Greenburg 在计算机图形学领域引入了辐射度方法，这是一项重要的新型渲染技术。它可以处理理想漫反射表面的能量平衡。也就是说平滑表面遵守如下的双向反射函数。<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/14.png" alt="辐射度方法"><br>定义在表面dx’的辐射度B(x’) 是整个可见半球的辐射通量。它是单位时间内单位（未经投影的）区域的能量，单位瓦特每平方米。定义是<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/15.png" alt="辐射度"><br>由此，为了计算半球域上的所有辐射量，我们可以简单地对场景中的所有表面进行积分。故，从公式(1)和(15)中我们可以得到：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/16.png" alt="辐射度_联系几何量"><br>如果x和x’之间存在遮挡，那么自发光项的贡献为零。否则，其贡献为：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/17.png" alt="辐射度_联系球面度"><br>其中e0是基于表面元素dx’的半球形辐照度。<br>同样，对于反射项，若表面被遮挡，则反射项对辐射度的贡献也是零。未被遮挡时，我们会得到：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/18.png" alt="辐射度_联系球面度"><br>其中H是单位时间内单位面积的半球域中入射的能量。 在这个推导中，我们转换了积分的顺序，并使用了(13)、(12)和(14)的特征。现在使用方程(17)和(18)，再基于(16)，我们能看到，渲染方程变为：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/19.png" alt="辐射度_结果"><br>这就是Goral等人推导出的公式(4) [1984]  </p><p>计算积分的辐射强度H对于计算辐射率中最终的Fij矩阵至关重要。这需要进行可见度计算，这可能是相当耗时的。由于矩阵方程是通过一些松弛迭代步骤来解决的，它基本上等同于对诺伊曼级数的前几项进行求和，即自发光量传播四次左右的散射量。使用松弛法需要计算全部的矩阵。松弛法还可以提供场景中所有表面的所有辐射强度。虽然在某些情况下，这可能是一个优势，但使用下面概述的蒙特卡洛方法可能更为先进。  </p><h2 id="马尔可夫链求解积分方程"><a href="#马尔可夫链求解积分方程" class="headerlink" title="马尔可夫链求解积分方程"></a>马尔可夫链求解积分方程</h2><p>马尔科夫链的使用可能是解决积分方程的最流行的数值方法。 它被广泛应用于队列论和中子迁移等领域。事实上，在辐射传导中使用马尔科夫链蒙特卡洛法已经有一段时间了[Siegel, Howell 1981]。在热传导方法中，一个特定波长的辐射量从某个特定表面中发射、反射和吸收。计算每个表面吸收的辐射量，依据于几何因素的估算，而精确的计算将是一个难以解决的问题。这类似于从光源到眼睛的光线追踪。但我们不采用这些方法，而是选择更直接地解决公式(1)，回到von Neumann 和 Ulam首次提出的早期蒙特卡洛方法[Rubenstein 1981]  </p><h3 id="有限空间求解"><a href="#有限空间求解" class="headerlink" title="有限空间求解"></a>有限空间求解</h3><p>作为介绍，我们首先在一个有限元的背景下介绍这个方法。这简化了符号，并使所涉及的基本思想变得明显。我们再一次注意到，这个例子中的方法可能比目前流行的辐射度松弛方案有很多优势：只需要计算可见点的辐射度，而整个辐射度矩阵的计算可以换成非常有限的一组选定矩阵元素。  </p><p>假设我们希望解决矢量方程：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/MCMC_0.png" alt="MCMC_0"><br>其中x和a是n维向量，x是未知量，且M=(m_ij)是n×n的矩阵。<br>现在从诺伊曼拓展中我们可以看到，对于矩阵M来说，特征值处于单位圆范围内的。x的解法由下公式给出：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/MCMC_1.png" alt="MCMC_1"><br>该方法通过矩阵乘法的路径平均对积分求积。亦即它依靠逐矩阵行和矩阵列的路径，构成一个迭代的矩阵乘积。对于路径中的每个点我们得到一系列行或列，可以用一个从1到n的整数来索引。  </p><p>构建一个概率空间O，其中每个样本ω是在每个离散时间内访问n个点之一的路径，即 ω =（n0，n1，…，n），对其中的每个n，都是1至n的正整数。对于路径ω的度量量k=l(ω)是有限的，但在其他方面是任意且一致的，并对应于k级矩阵幂。每条路径都被分配了一个概率p(ω)<br>如果我们想计算x的一个坐标值，记作x1，其值计算如下：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/MCMC_2.png" alt="MCMC_2"><br>对于所有路径的平均ω∈Ω，简单地取期望就可以得到这个量预期的量。  </p><p>路径的概率空间更加容易用马尔科夫链来构建。一个（静态的）离散马尔可夫链包括一组状态X，以及从一个状态x’∈X 到另一个状态x∈X的过渡概率p(x, x’)，还有一个初始状态的概率密度p(x)。一些状态的子集可以被指定为吸收态，即不允许从吸收态中转换出来。   </p><p>马尔可夫链产生的路径的概率是初始状态和所有过渡概率的积，直到达到一个吸收状态为止。因此，对于一条路径：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/MCMC_3.png" alt="MCMC_2"><br>有n-阶马尔可夫链路径概率：<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/MCMC_4.png" alt="MCMC_2"><br>在有限维度的情况下，我们让马尔科夫链的状态集作为向量或矩阵的索引集，即X = {1, … , n}。理应注意，尽管我们在选择过渡概率时是宽容的，但与非零状态对应的过渡概率必须是非负的。我们对积分解的估值极限完全独立于路径的概率分布，但收敛到极限的速度在很大程度上取决于选择过渡概率的方式。第5节给出了一套选择过渡概率的新方法。</p><h3 id="无限空间求解"><a href="#无限空间求解" class="headerlink" title="无限空间求解"></a>无限空间求解</h3><p>将马尔科夫链蒙特卡洛方法扩展到无限维度空间是很简单的。对于眼前的积分方程，我们注意到它是第二类弗雷德霍姆积分方程的变体。表面在反射和透射方面的无源被动性保证了诺伊曼级数的收敛。我们只需用表面上的点x的集合来代替状态集，计算这些点的流程程序如下：  </p><ol><li>在场景中选择一个通过视口可见的点x’到视口上选定的像素x。  </li><li>加上辐射强度。  </li><li>对于马尔可夫链路径中的度量<br>3.1 选择点x’’并计算几何因子g(x,x’’)。<br>3.2 计算反射率ρ(x, x’, x’’) 并乘以e(x’, x”)。<br>3.3 将这一结果加入到像素辐射强度中。   </li></ol><p>应知，计算辐照度和散射系数仅仅是计算纹理贴图和光照模型的问题。计算几何因子实际上就是光线追踪的光线对象求交。还要注意的是，通过以选定的角度射出射线并找到最近的交点来选择马尔可夫路径上的下一个点x’’，我们实际上是在进行有效的重要性采样优化。也就是说，我们不需要计算另两个闭塞点x’, x’’的积分，因为我们知道这个积分将是零。这与辐射度算法中的松弛过程相反，后者总是从所有表面获取能量贡献。  </p><h2 id="分层采样"><a href="#分层采样" class="headerlink" title="分层采样"></a>分层采样</h2><p>我们现在提出了一些新的减少方差的技术，以解决渲染方程的问题。然而，我们必须指出，这里所指出的技术能够应用的范围要广得多。一般来说，它们对积分特别困难的各种蒙特卡罗积分问题都有帮助。在这种情况下，比以前已知的方法所多增加的开销都变得可以忽略不计。我们提出了五种方法，它们越来越多地利用了有价值的被积样本的优点。下面概述的所有技术都受到分层抽样的启发。  </p><h3 id="序列一致采样"><a href="#序列一致采样" class="headerlink" title="序列一致采样"></a>序列一致采样</h3><p>第一种采样技术源于一种常见的顺序抽样策略。通常情况下，积<br>分的样本被反复收集，直到积分估计的样本方差低于一个固定的<br>阈值。这种策略在[Lee, Redner and Uselton 1985]中被证明是有优势的，他们在图像的感兴趣部分收集到了许多样本，同时在不感兴趣的部分收集到的样本则很少。  </p><p>不幸的是，这种顺序策略与分层采样并不兼容。在分层采样技术中，感兴趣的领域被划分为子单元。Lee使用每像素8个单元的固定细分，并在每个单元内随机抽取样本。理想情况下。当每个均匀划分单元收集一个样本时，可以获得更好的收敛性。这就是所谓的抖动采样方法。通常我们认为单元的中心形成一个网格。顺序取样<br>和抖动取样之间的不相容性是由于在精确知道将采集多少个样本<br>之前，不可能对采样域进行均匀的细分。  </p><p>顺序均匀取样是通过保持一棵不同大小的单元树来实现的。不同大小的单元。每次取样时，首先选择一个单元，然后再分成若干单元。原始单元的旧样本必须在一个新的子单元中。新的样本则被选在相反的单元中。一个简单的图示将说明这一技术。<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/HS_0.png" alt="SUS">   </p><p>为了投射一个新的样本点，我们遍历树，直到遇到一个未访问的叶子单元。然后我们把叶子单元分成两半，把样本投到空的那一半单元。  </p><ol><li>如果该节点是一个内部节点<br>1.1 选择一个子节点<br>1.2 完善所选择的子节点<br>1.3 返回  </li><li>否则，分割叶子节点  </li><li>将旧样本传播到包含它的子叶中。  </li><li>在剩余的空子叶上投下一个新样本  </li></ol><p>我们怎样才能保证进行尽可能均匀的细分？一种方法是以广度优先的顺序遍历采样树。在分割更深的节点之前，在每一级都分割一个叶子节点。这种策略产生了高度有序的样本分布，基本上是在区间内扫描。一个更好的方法是以随机顺序广度优先分割节点。以下流程体现了这种规划策略。  </p><ol><li>如果其中一个是叶子，就选择它。  </li><li>如果层(左)&lt;层(右)且左边是平衡的，选择左边的节点。  </li><li>如果层(右)&lt;层(左)且右是平衡的，选择右边的节点。  </li><li>否则就随机选择。  </li></ol><p>请注意，这个策略实际上是在整个区间内进行随机搜索，而不是<br>集中在任何特定区域。  </p><h3 id="多重维度情况"><a href="#多重维度情况" class="headerlink" title="多重维度情况"></a>多重维度情况</h3><p>上述算法很容易扩展到更高的维度，只需使用一种由Bentley[Bentley 1979]提出的被称为K-D树的数据结构即可。在这种数据结构中，域被一个垂直于连续共轴的超平面连续地分成两半。因此，对于一个单位区域，k-d树首先沿着垂直线进行细分，然后在下一级沿着水平线进行细分。上述统一的子节点选择规则确保了统一的细分，不需要任何修改。对路径空间的推广是直接的。  </p><h3 id="分层整合"><a href="#分层整合" class="headerlink" title="分层整合"></a>分层整合</h3><p>上述技术的第三个版本利用了以下事实。每个样本的单元都样本本身的记录。在这种情况下我们就可以计算出一个黎曼和，用单元的大小和样本的值作为积分。Yakowitz [Yakowit et al 1978]提出了这种方法的一个变体（使用样本本身作为边界点，没有分层）。他发现在一维中的方差为O(n^-4)，而在二维中的方差为O(n^-2)。这大大优于O(n^-1)的简单蒙特卡洛法。我们的技术分析仍在进行中并将出现在一篇配套的论文中。但依据对我们样本的分层结果，有早期的证据表明，这是一种优越的整合技术。  </p><p>每当一个单元被分割，它对总积分的贡献就被分成两半。新的积分样本被乘以空单元的大小。在分割和取样发生后，从叶子到根的路径被遍历，更新存储在每个节点的积分为其子节点的积分之和。通过保持非根部内部节点的积分，我们能够通过样本的密度来自动缩放规模，以保持一个恒定的度量。  </p><p>图3显示了与传统蒙特卡罗技术相比，二维积分的收敛情况。积分估计值与样本数的关系图。上面显示的是传统的估计，下面显示的是分层积分。我们正在对平面上的一个连接区域进行简单的阶梯函数积分。<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/fig3.png" alt="图3">   </p><h3 id="自适应分层整合"><a href="#自适应分层整合" class="headerlink" title="自适应分层整合"></a>自适应分层整合</h3><p>这一技术的第四个阐述涉及到除了领域内样本的均匀性之外的其他标准。在这一变化中，我们试图将样本集中在领域的有趣部分，并对积分几乎为常数的那些区域进行稀疏的采样。  </p><p>我们寻求树的有趣部分并进行进一步标准完善。如何将这些标准纳入算法中？很容易想到，序列一致采样的子节点选择规则是设置概率阈值的一种方式。在单位区间内选择一个统一的随机数。如果规则说要选择左边或右边的子节点，那么均匀规则会计算出一个阈值是1或0。如果规则说要随机选择，则阈值被设置为0.5。 </p><p>现在让我们计算一些阈值 φ1, … ,φk，要考虑到所有这些阈值函数，一个有效的方案是形成它们的凸组合，作为全局阈值φ，由以下公式给出<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/AHI.png" alt="AHI"><br>每个φ为其对应的阈值函数提供一个权重，以便总的策略可以进行调整。  </p><p>哪些是有用的阈值函数？ 我们已经找到了一些，但很明显，还有很多有待发现。我们发现有用的阈值函数包括：1）均匀采样阈值；2）完全随机阈值（φ=.5）；3）两个子节点的积分之差；4）这个子节点的活动变化历史（可能是积分的方差，或一些加权的时间历史）；5）可以预测到的光照先验函数。  </p><p>到目前为止，我们在寻找适应性标准方面的实验还没有取得很大的成功。我们没有使用普适性方法计算最终图像。  </p><h3 id="非一致性采样：重要性采样的类似方法"><a href="#非一致性采样：重要性采样的类似方法" class="headerlink" title="非一致性采样：重要性采样的类似方法"></a>非一致性采样：重要性采样的类似方法</h3><p>最后，第五种技术考虑到了重要性采样。与其把一个叶子单元完全分成两半，不如沿着一个代表某种概率密度函数中位数的超平面来划分。 所选择的超平面是由第二种技术中的k-d树的级别所决定的。将概率密度表示为一个综合分布函数，选择中位数超平面是通过快速的折半查找来实现的：为了找到概率密度f(x)的中位数，我们只需搜索F(x)=.5的那一点。  </p><p>重要性抽样是一种非常重要的降低方差的技术，在解决渲染方程时可以发挥很大的优势。  </p><h2 id="对渲染方程的应用"><a href="#对渲染方程的应用" class="headerlink" title="对渲染方程的应用"></a>对渲染方程的应用</h2><p>上面介绍的蒙特卡洛算法都可以应用到渲染算法的解决方案中。例如，序列一致采样被用来对景深模糊的光圈进行取样。自适应分层整合被用来对像素进行子采样。沿着中位数分割的重要性采样被用于选择一个方向来拍摄下一条光线。我们将照明模型存储为一个总和面积表[Crow 1985]给出一个概率分布函数，它可以经过二进制搜索来寻找反射单元中的中值。由于我们搜索的是光照模型的中值超平面，所以域的非线性变换并不特别重要。我们只需将一对输入和输出的半球体投射到切平面上。  </p><p>将路径的方法与传统的光线追踪算法进行比较是很有意思的。事实上，将传统的光线追踪转换为这种算法是非常容易的。我们基本上是执行传统的光线追踪算法，但我们不是在每个表面上进行光线树的分支，而是只遵循其中的一个分支，在树上给出一个路径。我们总是向已知的光源投射，当然，这些光源可能是扩展光源。因此，光线追踪与积分方程法的示意图是这样的。<br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/appli.png" alt="appli">  </p><p>现在这张图指出了一个重要的现象。由于表面的无源性，众所周知，第一次散射射线和光源射线是最重要的，因为它们对像素积分变化幅度的贡献最大。 第二次和更高一次的光线散射射线对积分变化幅度的贡献要小得多。但是传统的光线追踪法恰恰把大部分的工作花在了那些对图像的变化幅度贡献最小的光线上，它计算了太多的高传输次数的光线。 路径积分方程法避免了这种缺点。因为路径是一棵分枝率为1的树，有多少条不同的第一次散射射线，就有多少条高次散射射线。这对于减少运动模糊、景深和分布式光线追踪中的其他效果的差异非常重要。  </p><p>这张图还指出了传统随机光线追踪的另一种算法。与其计算一棵分支树，不如计算一条以概率方式选择射线的路径。<br>对于有很多反射和折射的场景来说，这大大减少了一个给定像素所要计算的光线物体交叉点的数量，并以极少的编程工作完成了光线追踪的显著加速。然而，对于这种新的快速光线追踪形式——路径追踪，我们发现，保持对每个像素的反射、折射和阴影射线类型的正确比例是非常重要的。与其完全随机地选择射线方向，不如遵守以下两种规则。 第一种方法，跟踪每种射线类型的分布数量。通过改变每种类型的概率，确保射线类型的样本分布与所需的分布密切相关，这样就能更确定样本分布是匹配的。这就是我们实际实施的方法。 第二种方法是让射线被随机选择，但按期望分布与所产生的加权样本分布的比例来衡量每个射线类型的贡献。  </p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>图5和图6显示了积分方程技术的结果图像。在每个表面元素被击中时，从一个由高光、漫反射和透射系数决定的分布中计算出一个随机变量。这个随机变量被用来选择从表面元素射出的一条射线。在每个光源上选择一个随机点，作为一条光线的目标。实际使用的减少方差的方法是选择新射线的漫射方向、镜面方向和折射方向的多维顺序采样。多维序列采样也被用来选择光源和成像孔径上的点。分层积分被用来对像素值进行抗锯齿处理。 这两幅图像都没有使用自适应或非一致性采样。很明显，重要性采样将大大改善图像的价值。虽然重要性采样的理论很简单，也很直截了当，但还没有做到。此外，跟踪每个像素的变化量和收集顺序已被证明是一个有重要意义的加速。然而，我们的项目对这些图像没有这样做，我们计算了一个每个像素的恒定的40条路径。  </p><p><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/fig5.png" alt="fig5"><br><img src="/2022/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/fig6.png" alt="fig6">  </p><p>图5显示了一个通过两种技术渲染的模型。左边是通过标准的光线追踪技术渲染的模型（尽管环境系数被设置为0，以及上面提到的单一分支比率的加速）。右边的图片显示的是通过积分方程渲染的结果。两幅图像都是256×256像素，每个像素有固定的40条路径。这些图像是在IBM-4341上计算的。第一幅图像花了401分钟的CPU时间，第二幅图像花了533分钟。请注意，球体在阴影中的区域吸收了光线追踪图片中缺少的环境照明。另外，光线从球体的底部反弹，照亮了底层平面。  </p><p>在图6中，我们展示了一幅图像，说明了积分方程技术的力量。场景中的所有物体都是中性的灰色，除了绿色的玻璃球和基础多边形（略带红色）。灰色物体上的任何颜色在光线追踪图像中都会消失。 请注意，绿色的玻璃球在场景中的物体上投下了微小的光线。在右上方的扁球形的底部，有颜色从浅色的基础多边形中渗出。为了便于比较的目的，这个场景中的不透明表面是符合兰伯特模型的，但对可以使用的光照模型没有限制。图6是一张512乘512像素的图像，每个像素有40条路径。它是在IBM 3081上计算的，消耗了1221分钟的CPU时间。Al Barr提供了这个图像的模型。</p><h3 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h3><p>感谢Al Barr、Tim Kay、RobCook、Jim Blinn以及CS286计算机图形研讨会的成员，感谢他们的技术讨论。我感谢IBM、洛杉矶科学中心的Juan Rivero和Yorktown Heights Research的Alan Norton向加州理工学院捐赠了大量的主机运行时长。我还要感谢审稿人提出的许多周到的意见。</p>]]></content>
    
    
    <categories>
      
      <category>文章翻译与笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
      <tag>经典论文</tag>
      
      <tag>James T. Kajiya</tag>
      
      <tag>翻译</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
