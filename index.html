<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Quercus的技术记录</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Quercus的技术记录">
<meta property="og:url" content="https://quercussprings.github.io/index.html">
<meta property="og:site_name" content="Quercus的技术记录">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Quercus">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Quercus的技术记录" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Quercus的技术记录</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://quercussprings.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-leetbook笔记（三）排序专题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/20/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2024-02-20T14:31:20.000Z" itemprop="datePublished">2024-02-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/20/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/">leetbook算法笔记（三）排序专题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h3><ul>
<li><p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] &#x3D; r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的。如{3,  1,  2_1, 2_2 }排序为{1, 2_2, 2_1, 3 }就是不稳定的。</p>
</li>
<li><p>稳定性的意义：当要排序的内容是一个对象的多个属性，且其原本的顺序存在意义时，如果我们需要在二次排序后保持原有排序的意义，就需要稳定算法</p>
</li>
</ul>
<h3 id="时间复杂度O-n-2-级别排序"><a href="#时间复杂度O-n-2-级别排序" class="headerlink" title="时间复杂度O(n^2)级别排序"></a>时间复杂度O(n^2)级别排序</h3><h4 id="🚩冒泡排序"><a href="#🚩冒泡排序" class="headerlink" title="🚩冒泡排序"></a>🚩冒泡排序</h4><ul>
<li><p>基础写法：双重循环遍历，一边比较一边将较大值或较小值两两交换，将最大或最小值冒泡到最后一位</p>
<ul>
<li>&#96;&#96;&#96;c++<br>for(int i&#x3D;0;i&lt;array.length-1;i++){<br>for(int j&#x3D;0;j&lt;array.length-1-i;j++){<br>    if (array[j] &gt; array[j + 1]) {<br>        swap(array,j,j+1);<br>    }<br>}<br>}<br>&#x2F;&#x2F;由外到内，第一个循环保证比较所有数，第二个循环保证正在进行比较的单个数和后边所有数都要比较<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 优化写法：使用一个变量记录当前轮次的比较是否发生交换，如果没有交换表示已经有序不再排序</span><br><span class="line"></span><br><span class="line">  - ```c++</span><br><span class="line">    boolean swaped;</span><br><span class="line">    for(int i=0;i&lt;array.length-1;i++)&#123;</span><br><span class="line">        //首先该轮比较暂没有交换</span><br><span class="line">        swapped=false;</span><br><span class="line">    	for(int j=0;j&lt;array.length-1-i;j++)&#123;</span><br><span class="line">            if(array[j]&gt;array[j+1])&#123;</span><br><span class="line">                swap(array,j,j+1);</span><br><span class="line">                swapped=true;</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        //如果没有交换则不再向后比较，已经有序</span><br><span class="line">        if(!swapped) break;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>对于swap函数来说，也有三种交换方法 临时数方法、加减运算法、异或运算法</p>
<ul>
<li>&#96;&#96;&#96;c++<br>&#x2F;&#x2F; 方法一: 利用临时数tmp<br>private void swap(int[] arr, int i, int j) {<br>int tmp &#x3D; arr[i];<br>arr[i] &#x3D; arr[j];<br>arr[j] &#x3D; tmp;<br>}<br>&#x2F;&#x2F; 方法二: 利用加减运算<br>private void swapCal(int[] arr, int i, int j) {<br>if(i &#x3D;&#x3D; j) return; &#x2F;&#x2F; 若无法保证swapCal被调用时满足 i !&#x3D; j，则需有此句，否则i &#x3D;&#x3D; j时此数将变为0<br>arr[i] &#x3D; arr[i] + arr[j]; &#x2F;&#x2F; a &#x3D; a + b<br>arr[j] &#x3D; arr[i] - arr[j]; &#x2F;&#x2F; b &#x3D; a - b<br>arr[i] &#x3D; arr[i] - arr[j]; &#x2F;&#x2F; a &#x3D; a - b<br>}<br>&#x2F;&#x2F; 方法三: 利用异或运算<br>private void swapXOR(int[] arr, int i, int j) {<br>if(i &#x3D;&#x3D; j) return; &#x2F;&#x2F; 若无法保证swapXOR被调用时满足 i !&#x3D; j，则需有此句，否则i &#x3D;&#x3D; j时此数将变为0<br>arr[i] &#x3D; arr[i] ^ arr[j]; &#x2F;&#x2F; a &#x3D; a ^ b，也可写成 arr[i] ^&#x3D; arr[j];<br>arr[j] &#x3D; arr[i] ^ arr[j]; &#x2F;&#x2F; b &#x3D; (a ^ b) ^ b &#x3D; a ^ (b ^ b) &#x3D; a ^ 0 &#x3D; a， 也可写成 arr[j] ^&#x3D; arr[i];<br>arr[i] &#x3D; arr[i] ^ arr[j]; &#x2F;&#x2F; a &#x3D; (a ^ b) ^ a &#x3D; (a ^ a) ^ b &#x3D; 0 ^ b &#x3D; b， 也可写成 arr[i] ^&#x3D; arr[j];<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  ​	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 选择排序</span><br><span class="line"></span><br><span class="line">- 基础写法：双重循环遍历数组，每一轮比较，可找到本轮最小元素的**下标**，将其交换至本轮的首位</span><br><span class="line"></span><br><span class="line">  - ```c++</span><br><span class="line">    int minid;</span><br><span class="line">    for(int i=0;i&lt;array.length-1;i++)&#123;  //注意最后一个数不用再新一轮比较</span><br><span class="line">        minid=i;</span><br><span class="line">        for(int j=i+1;j&lt;array.length;j++)&#123;	//注意要从i+1比较到最后一个数</span><br><span class="line">            if(array[minid]&gt;array[j])&#123;</span><br><span class="line">                minid=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(array,minid,j);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>二元选择排序</strong>写法：每轮比较时记录最小值和最大值的下标，可以把数组需要遍历的范围缩小一倍</p>
<ul>
<li>&#96;&#96;&#96;c++<br>public int[] selectionSortDouble(int[] arr) {<br>if (arr.length &lt; 2) return arr;<br>int n &#x3D; arr.length;<br>for (int i &#x3D; 0; i &lt; n - 1 - i; i++) { &#x2F;&#x2F; 每轮确定两个数字，因此上界也会动态变化<br>    int minIdx &#x3D; i, maxIdx &#x3D; i;<br>    for (int j &#x3D; i + 1; j &lt; n - i; j++) {<br>        if (arr[j] &lt; arr[minIdx]) minIdx &#x3D; j;<br>        if(arr[j] &gt; arr[maxIdx]) maxIdx &#x3D; j;<br>    }<br>    if(minIdx &#x3D;&#x3D; maxIdx) break; &#x2F;&#x2F; 若本轮最大值等于最小值，说明未排序部分所有元素相等，无需再排序<br>    swap(arr, i, minIdx);<br>    if(maxIdx &#x3D;&#x3D; i) maxIdx &#x3D; minIdx; &#x2F;&#x2F; 在交换 i 和 minIdx 时，有可能出现 i 即 maxIdx 的情况，此时需要修改 maxIdx 为 minIdx<br>    swap(arr, n - 1 - i, maxIdx);<br>}<br>return arr;<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">#### 插入排序</span><br><span class="line"></span><br><span class="line">- 交换法：从第二个数字开始，不断与前面数字交换，到大小合适不能交换为止</span><br><span class="line"></span><br><span class="line">  - ```c++</span><br><span class="line">    // 交换法插入排序</span><br><span class="line">    void insert_sort1(vector&lt;int&gt; &amp;nums)</span><br><span class="line">    &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        for (int i = 1; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = i - 1; j &gt;= 0 &amp;&amp; nums[j] &gt; nums[j + 1]; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums[j], nums[j + 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>移动法：从第二个数字开始，不断与前面的数字比较，前面数字不断向后移动，到合适位置插入一次即可</p>
<ul>
<li><p>&#96;&#96;&#96;c++<br>&#x2F;&#x2F; 移动法插入排序<br>void insert_sort2(vector<int> &amp;nums)<br>{<br>int n &#x3D; nums.size();<br>for (int i &#x3D; 1; i &lt; n; ++i)<br>{<br>    int t &#x3D; nums[i]; &#x2F;&#x2F; 暂存需要插入的数字<br>    int j &#x3D; i - 1;<br>    for (j; j &gt;&#x3D; 0 &amp;&amp; nums[j] &gt; t; –j)<br>    {<br>        nums[j + 1] &#x3D; nums[j];<br>    }<br>    nums[j + 1] &#x3D; t;<br>}<br>}</int></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### 时间复杂度O(nlogn)级别排序</span><br><span class="line"></span><br><span class="line">#### 希尔排序</span><br><span class="line"></span><br><span class="line">##### 基本思想</span><br><span class="line"></span><br><span class="line">1. 将待排序数组按照一定间隔分为多个子数组，即为每跳跃一定间隔取一个值组成一组，每组分别进行插排</span><br><span class="line">2. 逐渐缩小间隔进行下一轮排序</span><br><span class="line">3. 最后一轮时间隔为一，即为直接插排。而因为此时数组已经基本有序，故只需少量交换。</span><br><span class="line"></span><br><span class="line">希尔排序对有序程度较高的序列有较高的效率</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">//基础写法 /希尔增量序列Dm=N/2 Dk=(D(k+1))/2</span><br><span class="line">for(int gap = array.len/2;gap&gt;0;gap/=2)&#123;</span><br><span class="line">    //分组，直到gap=1或ID到组尾</span><br><span class="line">    //但对于计算机来说，它更喜欢从第 gap 个元素开始，按照顺序将每个元素依次向前插入自己所在的组这种方式</span><br><span class="line">    for(int groupStartID=0;groupStartID&lt;gap;groupStartID++)&#123;</span><br><span class="line">	//插排,每组第二个往后开始站起来找位置，组内每个数隔一个gap</span><br><span class="line">        for(int currentID=groupStartID+gap;</span><br><span class="line">            currentID&lt;array.len;couuentID+=gap)&#123;</span><br><span class="line">            //挑出来开始找位置</span><br><span class="line">            int currentNum=array[currentID];</span><br><span class="line">            //preID:该组该数前一个数的ID </span><br><span class="line">            //直到preID到小组开始且当前挑出数小于小组前一个数为止</span><br><span class="line">            for(int preID=currentID-gap;</span><br><span class="line">                preID&gt;=groupStartID&amp;&amp;currentNum&lt;array[preID];</span><br><span class="line">                preID-=gap)&#123;</span><br><span class="line">                //向后挪位置</span><br><span class="line">                arr[preID+gap]=arr[preID];</span><br><span class="line">            &#125;</span><br><span class="line">            //currentNum到位</span><br><span class="line">            arr[preIndex + gap] = currentNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>常见增量序列</p>
<ul>
<li><p>Hibbard增量序列(1,3,7,15,…):<br>$$<br>D_k&#x3D;2^k-1<br>$$</p>
</li>
<li><p>Knuth增量序列(1,4,13,40,..):</p>
</li>
</ul>
<p>$$<br>D_1&#x3D;1;D_{k+1}&#x3D;3·D_k+1<br>$$</p>
<ul>
<li>Sedgewick增量序列</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求Knuth增量序列</span></span><br><span class="line"><span class="type">int</span> maxKnuthNum=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//找最大Knuth数</span></span><br><span class="line"><span class="keyword">while</span>(maxKnuthNum&lt;=arr.len/<span class="number">3</span>)&#123;</span><br><span class="line">    maxKnuthNum=maxKnuthNum*<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> gap=maxKnuthNumber;gap&gt;<span class="number">0</span>;gap=(gap<span class="number">-1</span>)/<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="comment">//对于计算机来说，它更喜欢从第 gap 个元素开始，按照顺序将每个元素依次向前插入自己所在的组这种方式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=gap;i&lt;arr.len;i++)&#123;</span><br><span class="line">        <span class="type">int</span> currNum=arr[i];</span><br><span class="line">        <span class="type">int</span> preID=i-gap;</span><br><span class="line">        <span class="keyword">for</span>(;preID&gt;=<span class="number">0</span>&amp;&amp;currNum&lt;arr[preID];</span><br><span class="line">            preID-=gap)&#123;</span><br><span class="line">            arr[preID+gap]=arr[preID];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preID+gap]=currNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h5><p>希尔排列是较早地<strong>突破二次复杂度</strong>的排序算法，我们可以从<strong>逆序数</strong>的角度考察它为何能突破O(n^2)</p>
<p>在一个排列中如果任意一对数的前后位置与大小顺序相反，即前大后小，则这两个数构成<strong>逆序</strong>，一个排列中逆序的总数就是一个<strong>逆序数</strong>。任何排序都在减少逆序数直到为0</p>
<p>回顾冒泡排序和简单插入排序，它们每次交换只交换<strong>相邻</strong>元素，那么每次交换只能减少一个逆序。如果能跨越多个元素进行交换就<strong>可能</strong>一次减少多个逆序。选择排序确实是跨越多个元素的交换，实际上它减少逆序数的操作时间复杂度为O(n)，但它需要两轮比较，比较次数仍为O(n^2),所以选择排序整体复杂度为二次。</p>
<p>所谓“可能减少逆序”的情况，比如<img src="/2024/02/20/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/FILE\myBlog\Hexo_Blog\source_posts\leetbook笔记（三）排序专题\image-20240205112753322.png" alt="image-20240205112753322"></p>
<p>我们只交换了i和j，就使得逆序数由3变成了0。当然只是有可能出现这种情况。</p>
<p>这些O(nlogn)的排序，即希尔排序、堆排序、快速排序、归并排序都是实现了<strong>长距离交换元素</strong>进而使得时间复杂度优于二次</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h5><p>堆排序先将输入数组使用<strong>堆化方法(heapify)<strong>建立为一个</strong>大顶堆</strong>，反复取出堆顶并逆序排列，对剩余元素重建大顶堆，直到堆顶都拿出，即可将原数组从小到大完成排序。</p>
<blockquote>
<p>[!NOTE]</p>
<p>堆是符合一下两个条件之一的完全二叉树</p>
<ul>
<li>根结点的值&gt;&#x3D;子结点的值，称之为最大堆或大顶堆</li>
<li>根结点的值&lt;&#x3D;子结点的值，称之为最小堆或小顶堆</li>
</ul>
<p>完全二叉树是结点按从上至下、从左到右的顺序排列的二叉树</p>
</blockquote>
<p>一个直接的想法是在原数组之外新建一个数组来保存每次取得的堆顶，但这样会有O(n)级别的空间开销，一般用原地堆排序的技巧避免此开销</p>
<h5 id="原地堆排序"><a href="#原地堆排序" class="headerlink" title="原地堆排序"></a>原地堆排序</h5><ol>
<li>将原来待排序数组arr[]使用堆化方法建立为一个大顶堆。</li>
<li>交换堆顶和当前<strong>未排序部分</strong>最末尾元素，则堆顶元素得到排序（此时在数组最末尾）</li>
<li>剩余元素中只可能是当前堆顶（即上一步被交换的末尾元素）会造成堆失序，因此需要对堆顶调用一次调整堆序的下滤方法，恢复未排序部分的堆序</li>
<li>重复2 3，直到所有元素已排序</li>
</ol>
<h5 id="堆化过程-heapify"><a href="#堆化过程-heapify" class="headerlink" title="堆化过程(heapify)"></a>堆化过程(heapify)</h5><p>将待排序数组arr[]看作一个根结点为0的<strong>完全二叉树</strong>，那么其任意一个结点（假设下标为i）的左子结点下标为$2·i+1$，右子结点下标为$2·i+2$，父结点为$(i-1)&#x2F;2$。</p>
<p>堆化过程就是使整个树满足堆序性质的过程，即使得大顶堆arr的$arr[ (i-1)&#x2F;2 ]&gt;&#x3D;arr[ 2·i+1 ]且arr[ (i-1)&#x2F;2 ]&gt;&#x3D;arr[ 2·i+2 ]$，亦即任意一个结点大于等于其子结点。</p>
<p>而使得堆化过程实现的具体操作叫做（大顶堆的）<strong>下滤方法</strong>。依次对从最后一个<strong>非叶子结点</strong>到根结点执行下滤方法，即为堆化过程</p>
<blockquote>
<p>[!NOTE]</p>
<p>叶子节点无子结点，也就无下滤的必要。</p>
<p>最后一个非叶子结点下标为$(n-1)&#x2F;2$,n为数组长度</p>
</blockquote>
<h5 id="下滤方法-siftdown"><a href="#下滤方法-siftdown" class="headerlink" title="下滤方法(siftdown)"></a>下滤方法(siftdown)</h5><p>下滤方法是堆排序的<strong>核心</strong>方法，在原地堆排序中有两处应用</p>
<ul>
<li>排序开始前，创建大顶堆（堆化过程）时使用下滤方法</li>
<li>原地排序时，对堆顶恢复未排序部分的<strong>堆序</strong></li>
</ul>
<blockquote>
<p>[!note]</p>
<p>此处不要模糊我们排序的最终目标是<strong>序列有序</strong>，序列有序（以从大到小为例）体现在树上就是父结点&gt;左子结点&gt;右子结点。而<strong>堆有序</strong>（以大顶堆为例），仅仅是父结点&gt;左结点且父结点&gt;右节点，对左右结点的关系没有要求。</p>
</blockquote>
<p>下滤方法在堆数据结构中用于堆顶元素的删除操作，先来理解它如何删除堆顶</p>
<ol>
<li>删除堆顶，堆中元素-1，将当前序列最后一个元素<strong>暂时</strong>置为堆顶</li>
<li>此时只有堆顶元素导致堆失序，于是<strong>交换其与左右子结点的较大者</strong></li>
<li>重复2 直到恢复堆序</li>
</ol>
<p>我们注意到<strong>交换父结点与左右子结点的<em>较大者</em></strong>这一步能够将堆有序转化为序列有序，因为它消除了左右子结点的逆序。这是下滤方法的本质。</p>
<p>理解了下滤方法删除堆顶，我们再回顾堆化过程，堆化过程就是分别对从最后一个<strong>非叶子结点</strong>到根结点执行下滤方法。</p>
<p>堆化之后的原地排序就是，每次交换当前堆顶和当前未排序序列最后一个元素时，新堆顶影响堆序，对它执行下滤方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="comment">//堆化方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> hole=(r<span class="number">-1</span>)/<span class="number">2</span>;hole&gt;=<span class="number">0</span>;hole--)&#123;</span><br><span class="line">        <span class="built_in">siftdown</span>(arr,hole,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下滤方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftdown</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> hole,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> target=arr[hole],child =hole*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(child&lt;=r)&#123;</span><br><span class="line">        <span class="comment">//满足child&lt;r则hole有右孩子，不满足则hole无右孩子，跳过</span></span><br><span class="line">        <span class="comment">//满足第二个条件表示hole有右孩子并且右孩子大于左，使得child为更大的右孩子下标</span></span><br><span class="line">        <span class="keyword">if</span>(child&lt;r&amp;&amp;arr[child+<span class="number">1</span>]&gt;arr[child]) child++;</span><br><span class="line">        <span class="keyword">if</span>(arr[child]&gt;target)&#123;</span><br><span class="line">            arr[hole]=arr[child];</span><br><span class="line">            hole=child;</span><br><span class="line">            child=hole*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[hole]=target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><h4 id="🚩快速排序"><a href="#🚩快速排序" class="headerlink" title="🚩快速排序"></a>🚩快速排序</h4><h5 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h5><p>快速排序由C.A.R.Hoare在1960年提出。在时间复杂度为$O(nlogn)$级别的几种排序算法中,大多数情况下效率更高，所以应用广泛。</p>
<p>它的基本思想是<strong>分治</strong>，确定<strong>主轴</strong>及<strong>分区</strong>是快速排序的核心，具体思路是</p>
<ol>
<li>从数组中取出一个数，称之为<strong>主轴或基数(pivot)</strong></li>
<li>遍历数组，使用<strong>分区方法</strong>，大于等于主轴的数字放到右边，小于主轴的数字放到左边。遍历完成后数组被分成了左右两个区域。</li>
<li>将左右两个区域视作两个数组，重复前两个步骤，直到排序完成</li>
</ol>
<p>主轴的选取有几种方式</p>
<ul>
<li><strong>主轴为起始元素</strong>（quickSortSimple）：即每次选取当前数组第一个元素作为主轴。<ul>
<li>优点：实现简单</li>
<li>缺点：如果输入是较为有序的数组，主轴不能均匀地分割数组。数组本身有序的极端情况下，复杂度退化到$O(n^2)$</li>
</ul>
</li>
<li><strong>主轴为随机下标元素</strong>（quickSortRandom）：即每次随机选取当前数组的下标，将该下标元素作为主轴<ul>
<li>优点：避免了较为有序数组不能均匀分割的情况</li>
<li>缺点：随机数算法本身耗费性能</li>
</ul>
</li>
<li><strong>主轴为左中右三数大小居中者</strong>（quickSortMedian3）：每次比较当前数组起始、中间和末尾三个元素的大小，选择大小居中者为主轴。<ul>
<li>优点：实现相对简单，且有效避免劣质分割</li>
<li>缺点：三数取中算法也消耗一定性能</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三数取中方法 (将 arr[l], arr[c], arr[r] 三者居中者置于下标 l 处)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">median3</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> c = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &gt; arr[c]) <span class="built_in">swap</span>(arr, l, c); <span class="comment">// 左中，大者居中</span></span><br><span class="line">    <span class="keyword">if</span> (arr[c] &gt; arr[r]) <span class="built_in">swap</span>(arr, c, r); <span class="comment">// 中右，大者居右，此时最大者居右</span></span><br><span class="line">    <span class="keyword">if</span> (arr[c] &gt; arr[l]) <span class="built_in">swap</span>(arr, l, c); <span class="comment">// 左中，大者居左，此时中者居左</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>快排中的核心方法是<strong>分区方法</strong>（partition）。分区方法执行后，主轴左边元素均小于主轴，主轴右边元素均大于等于主轴元素。分区方法返回主轴下标p</p>
<p>选定某数作为主轴后，都**先将选定的主轴置于当前数组的起始位置<code>l</code>**，设置一个初始值为<code>j=l+1</code>的<code>j</code>，动态地寻找最终主轴下标。由左至右地将主轴后所有元素依次与主轴元素比较，如果小于主轴就将该数字与下标为<code>j</code>的数字交换，之后j右移一位，目标是使得j的前一位总是当前最后一个小于主轴的元素，遍历结束后交换下标为l的元素（即主轴）和下标为j-1的元素。此时主轴为j-1，返回j-1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr,<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j=l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=j;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;arr[l])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr,i,j);<span class="comment">//交换后的arr[j]就是当前最后一个小于主轴的元素</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr,l,j<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> j<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="递归单轴快排"><a href="#递归单轴快排" class="headerlink" title="递归单轴快排"></a>递归单轴快排</h5><p>在确定主轴位置后，递归地对主轴左右两侧执行排序过程。那么递归函数需要传入待排序序列arr和本次递归要处理的部分其左右界。当所有递归都到达基准情形是排序完成，因为是递归原地交换，递归过程无需返回，为<strong>尾递归</strong></p>
<blockquote>
<p>[!note]</p>
<p>尾递归是指一个函数在调用自身之后不再执行任何其他操作，而是将返回值直接传递给函数调用的上级</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*****首位轴递归单轴快排*****//</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">quickSortSimple</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="built_in">size</span>()&lt;<span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="built_in">quickSortSimpleRecursion</span>(arr,<span class="number">0</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首位轴递归方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSortSimpleRecursion</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//left==right arr只有一个元素，完成递归</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="comment">//获得主轴p</span></span><br><span class="line">        <span class="type">int</span> p=<span class="built_in">partition</span>(arr,l,r);</span><br><span class="line">        <span class="built_in">quickSortSimpleRecursion</span>(arr,l,p<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSortSimpleRecursion</span>(arr,p+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//************************//</span></span><br><span class="line"><span class="comment">//***三数取中轴递归单轴快排***//</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">quickSortMedian3</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="built_in">size</span>()&lt;<span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="built_in">quickSortSimpleMedian3</span>(arr,<span class="number">0</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//三数取中轴递归方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSortMedian3Rec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//left==right arr只有一个元素，完成递归</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="comment">//获得主轴p</span></span><br><span class="line">        <span class="type">int</span> p=<span class="built_in">partition</span>(arr,l,r);</span><br><span class="line">        <span class="built_in">quickSortSimpleMedian3Rec</span>(arr,l,p<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSortSimpleMedian3Rec</span>(arr,p+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//三数取中轴</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">median3</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//大小居中者为轴，即左边界left</span></span><br><span class="line">    <span class="keyword">if</span>(arr[l]&gt;arr[mid]) <span class="built_in">swap</span>(arr,l,mid);<span class="comment">//使得l mid较大者居中</span></span><br><span class="line">    <span class="keyword">if</span>(arr[mid]&gt;arr[r]) <span class="built_in">swap</span>(arr,mid,r);<span class="comment">//使得mid r较大者居右，此时r为最大</span></span><br><span class="line">    <span class="keyword">if</span>(arr[mid]&gt;arr[l]) <span class="built_in">swap</span>(arr,l,mid);<span class="comment">//使得l mid较大者居左，此时l为中间数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**************************//</span></span><br><span class="line"><span class="comment">//*****随机轴递归单轴快排******//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSortMedian3</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="built_in">size</span>()&lt;<span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="built_in">quickSortRandomRec</span>(arr,<span class="number">0</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机轴递归方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSortRandomRec</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="comment">//[l+1,r]随机数  [a,b]随机数(rand() % (b-a+1))+ a</span></span><br><span class="line">		<span class="type">int</span> randID=(<span class="built_in">rand</span>()%(r-l))+l+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(arr,l,randID);</span><br><span class="line">        <span class="type">int</span> p=<span class="built_in">partition</span>(arr,l,r);</span><br><span class="line">        <span class="built_in">quickSortRandomRec</span>(arr,l,p<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSortRandomRec</span>(arr,p+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//****************************//</span></span><br></pre></td></tr></table></figure>



<h5 id="非递归-栈迭代-单轴快排"><a href="#非递归-栈迭代-单轴快排" class="headerlink" title="非递归(栈迭代)单轴快排"></a>非递归(栈迭代)单轴快排</h5><p>递归方法思路直接，若要求不用递归形式实现快排，便可利用<strong>栈（LIFO）保存区间左右界</strong>。每次partition()方法划分确定主轴p后，将得到的p左右两侧区间的边界l、r压入栈中</p>
<ol>
<li>初始时左右界为[0，arr.size()-1]，将它们按r、l顺序入栈</li>
<li>while循环判断当前栈是否空，不空则弹出栈顶的一对边界（l、r顺序）<ol>
<li>若满足l&lt;r，则对当前这对l、r的区间继续执行partition()分区方法，得到该区间的主轴p</li>
<li>若满足l&lt;p，则将p左侧区间的左右界压入栈(p-1、l顺序入栈)；若满足r&gt;p则将p右侧区间的左右界压入栈(r、p+1)顺序</li>
</ol>
</li>
<li>while结束时排序完成，返回arr</li>
</ol>
<h5 id="双轴快排"><a href="#双轴快排" class="headerlink" title="双轴快排"></a>双轴快排</h5><p>双轴快排是单轴快排的改进，需要<strong>注意细节</strong></p>
<p>之前的单轴快排每次递归地确定当前区间的主轴，并利用该主轴将当前区间再划分为两个部分。双轴快排则以<strong>两个轴</strong>（pivot1、pivot2）将当前区间划分为<strong>三个子区间</strong>。我们将$[left,pivot)$称作区间1，$(pivot1,pivot2)$称作区间2，$(pivot2,right]$称作区间3.</p>
<p>对于这三个区间有</p>
<ul>
<li>区间1：$arr[i]&lt;arr[p1],i∈[left,p1)$</li>
<li>区间2：$arr[p1]&lt;&#x3D;arr[i]&lt;&#x3D;arr[p2],i∈(p1,p2)$</li>
<li>区间3：$arr[i]&gt;arr[p2],i∈(p2,right]$</li>
</ul>
<p>对这三个子区间再执行划分区间的过程，直到无法划分时排序完成</p>
<p>具体过程如下</p>
<ol>
<li><p>dualPivotQuickSort执行开始，以left&lt;right为条件，<strong>只对大于等于2的区间执行双轴快排</strong></p>
</li>
<li><p><strong>令左右两端元素中较小者居左</strong>，之后以left为p1初始的下标，right为p2初始的下标，保证p1&lt;p2。</p>
</li>
<li><p>设置index&#x3D;left+1，lower&#x3D;left+1，upper&#x3D;right-1。</p>
<ul>
<li>index表示当前考察的元素下标。</li>
<li>lower是动态向右扩展的下标，用来推进到p1最终位置。<strong>任意时刻[left,lower)中的元素总确定在区间1中</strong>。</li>
<li>upper是动态向左扩展的下标，用来推进到p2最终位置。<strong>任意时刻(upper,right]中的元素总确定在区间3中</strong>。</li>
<li>初始时，lower&#x3D;&#x3D;left+1，upper&#x3D;&#x3D;right-1，表示left和right实际上分别在区间1和2中，但lower和upper本身不在区间1和2中；当循环结束时，lower–和upper++就是主轴最终p1和p2的位置。</li>
</ul>
</li>
<li><p>while循环遍历从lower（即left+1）到upper（即right-1）的所有元素，通过每个元素与arr[left]左轴值和arr[right]右轴值的比较、交换，将每个元素正确地置于区间1（&lt;arr[p1]）、区间2（arr[p1]&lt;&#x3D;arr[index]&lt;&#x3D;arr[p2]）和区间三中（&gt;arr[p2]）<br>与此同时，lower动态右移，upper动态左移，对这三个区间进行动态调整，index++，遍历所有元素。亦即在单个循环内：</p>
<ol>
<li><p>循环边界是(index&lt;&#x3D;upper)，因为就算三个区间动态调整，但是upper右边（不含upper）的元素是确定在区间3（即大于arr[p2]）的。那么index向右不能超过upper，而upper本身不一定。故是index&lt;&#x3D;upper。</p>
</li>
<li><p>首先考察arr[index]是否在区间1，若在区间1将该元素至于lower右侧，区间1向右扩展。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(arr[index]&lt;arr[left])&#123;</span><br><span class="line">	<span class="built_in">swap</span>(arr,index,lower);</span><br><span class="line">	lower++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若不在区间1，检查是否在区间3，若满足则在区间3。此时将该元素置于upper右侧，且区间3向左扩展。</p>
<blockquote>
<p>[!note]</p>
<p>不同于2. 直接交换arr[index]和arr[lower]，2.中因为尽管lower在交换前不一定在区间1中，但是index是不断向左移动的，最后一定能判断到与原lower交换位置后与arr[left]的关系。而对于3.来说，如果还像2.一样直接交换，无法判断换到区间2的原upper与arr[right]的关系，因为index是不断向左移动的。</p>
</blockquote>
<p>所以在交换之前应该实现一种操作，使得与arr[index]交换的arr[upper]确定是哪个区间的元素。首先确定是不是区间3中的元素。于是可以先从当前arr[upper]向左考察是否有arr[upper]&gt;arr[right]，若有则表示arr[upper]在区间3，直接upper–左扩跳过。直到不满足时表示此时arr[upper]确定不是区间3，准备交换。注意左扩不能扩到现在的index，要保证循环边界有效。<br>此时还不能确定该元素在区间1还是区间2中，对其再执行一次4.2.相同的步骤</p>
<p>上述完成了对arr[index]的检查和处理，此时index++，检查处理下一个元素。</p>
</li>
</ol>
</li>
<li><p>当while(index&lt;&#x3D;upper)结束时，所有元素检查处理完毕。此时最后一个确定在区间1的元素下标是lower–，最后一个确定在区间3的元素下标是upper++。将其分别与左右轴p1和p2交换，使得左右轴归位，排序结束。</p>
</li>
</ol>
<p><img src="/2024/02/20/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/FILE\myBlog\Hexo_Blog\source_posts\leetbook笔记（三）排序专题\1652692972-TbEiju-image.png" alt="image.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *     区间1               区间2                         区间3</span></span><br><span class="line"><span class="comment"> * +------------------------------------------------------------+</span></span><br><span class="line"><span class="comment"> * |  &lt; pivot1  | pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    | &gt; pivot2  |</span></span><br><span class="line"><span class="comment"> * +------------------------------------------------------------+</span></span><br><span class="line"><span class="comment"> *              ^                         ^         ^</span></span><br><span class="line"><span class="comment"> *              |                         |         |</span></span><br><span class="line"><span class="comment"> *            lower                     index      upper</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dualPivotQuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[left]&gt;arr[right])&#123;</span><br><span class="line">			<span class="built_in">swap</span>(arr,left,right);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">        <span class="type">int</span> index=left+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> lower=left+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> upper=right<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index&lt;=upper)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[index]&lt;arr[left])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr,index,lower);</span><br><span class="line">                lower++</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(arr[upper]&gt;arr[right]&amp;&amp;index&lt;upper)&#123;</span><br><span class="line">                    upper--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">swap</span>(arr,index,upper);</span><br><span class="line">                upper--;</span><br><span class="line">                <span class="keyword">if</span>(arr[index]&lt;arr[left])&#123;</span><br><span class="line">                    <span class="built_in">swap</span>(arr,index,lower);</span><br><span class="line">                    lower++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//lower--;upper++;</span></span><br><span class="line">        <span class="built_in">swap</span>(arr,left,--lower);</span><br><span class="line">        <span class="built_in">swap</span>(arr,++upper,right);</span><br><span class="line">        <span class="built_in">dualPivotQuickSort</span>(arr,left,lower<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dualPivotQuickSort</span>(arr,lower+<span class="number">1</span>,upper<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dualPivotQuickSort</span>(arr,upper+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><h4 id="🚩归并排序"><a href="#🚩归并排序" class="headerlink" title="🚩归并排序"></a>🚩归并排序</h4><h5 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h5><p>将原待排序数组<strong>递归或迭代</strong>地分为左右两半，直到数组长度为1，然后合并左右数组，在合并中完成排序。将问题转化为两个有序数组的合并。<br>我们发现在第二个列表向第一个列表逐个插入的过程中，由于第二个列表已经有序，所以<strong>后续插入的元素一定不会在前面插入的元素之前</strong>，那么这样一来我们最多只需要将两个有序数组遍历一次（而不是两次）就能完成合并。<br>我们可以开辟一个新数组，使用两个指针来遍历原有的两个数组不断地将较小的数字添加到新数组中。</p>
<p>简单来说</p>
<ol>
<li>将序列中待排序数字分为若干组，每个数字为一组。</li>
<li>将若干个组两两合并，保证合并后的组是有序的。</li>
<li>重复第二步直到剩下一组。</li>
</ol>
<p>可以通过**自顶向下(top-down)<strong>或</strong>自底向上(bottom-up)**的方式实现归并排序。</p>
<p>自顶向下 (top-down)：从输入数组出发，不断二分该数组，直到数组长度为1，再执行合并。适合用<strong>递归</strong>实现。</p>
<p>自底向上 (bottom-up)：从输入数组的单个元素出发，一一合并，二二合并，四四合并直到数组有序。适合用<strong>迭代</strong>实现。</p>
<h5 id="原地归并"><a href="#原地归并" class="headerlink" title="原地归并"></a>原地归并</h5><p>除了使用前面临时数组，我们还可以使用<strong>原地旋转交换（或称手摇算法、内存反转算法、三重反转算法，block swap algorithm）</strong>使得其辅助空间为$O(1)$ （但是递归空间为$O(logn)$ 所以总的复杂度仍为$O(logn)$）</p>
<p>以456123为例，欲将456和123交换位置转换为123456，需要</p>
<ol>
<li>旋转456，得到654【654123】</li>
<li>旋转123，得到321【654321】</li>
<li>旋转654321得到123456</li>
</ol>
<p>应用原地旋转交换的原地归并，过程如下</p>
<ol>
<li><p>记<strong>左数组</strong>第一个元素下标为i，记右数组第一个数下标为j。</p>
</li>
<li><p>i向后遍历，找到左数组中第一个<strong>大于</strong>右数组第一个数字（即arr[j]）的数，此时有arr[i]&gt;arr[j]。</p>
</li>
<li><p>以index暂存<strong>右数组</strong>第一个元素的下标，即index&#x3D;j</p>
</li>
<li><p>找到右数组中第一个<strong>大于等于</strong>arr[i]的数，记其下标为j。此时必有[i,index-1]下标范围序列<strong>大于</strong>[index，j-1]下标范围序列</p>
</li>
<li><p>通过三次反转交换[i,index-1]和[index，j-1]序列，即依次反转[i,index-1]、反转[index，j-1]、反转[i，j-1]</p>
</li>
<li><p>重复上述过程直到<code>(i&lt;j&amp;&amp;j&lt;=r)</code></p>
<p>注意第四步找的是右数组第一个<strong>大于等于</strong>arr[i]的数，如果找严格大于将破坏稳定性</p>
</li>
</ol>
<p>我们以{1，2，4，6，7}和{3，5，8，9}两个已排序的序列为例，演示原地归并</p>
<ol>
<li>在{1，2，4，6，7}中找到一个大于3的数4，其下标为i&#x3D;2，那么右数组第一个元素的下标为index&#x3D;j&#x3D;5。在{3，5，8，9}中找到第一个大于arr[i]&#x3D;arr[2]&#x3D;4的数5，其下标为6，j&#x3D;6。</li>
<li>这样使得[0,i-1]必然是最小序列，[index，j-1]必然小于arr[i]，而后大于[0，i-1]。因此交换[i，index-1]和[index，j-1]使得这部分在数组中有序。</li>
<li>交换后，继续执行上述过程直到<code>i&lt;j&amp;&amp;j&lt;=r</code>。</li>
</ol>
<p><img src="/2024/02/20/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/FILE\myBlog\Hexo_Blog\source_posts\leetbook笔记（三）排序专题\1652692350-OvThvJ-image.png"></p>
<p><img src="/2024/02/20/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/FILE\myBlog\Hexo_Blog\source_posts\leetbook笔记（三）排序专题\image-20240307170206066-1709802127443-3.png" alt="image-20240307170206066"></p>
<p>根据上述分析，原地相比非原地，空间消耗较少，采用 自底向上原地归并排序 时空间复杂度为常数级 O(1)，但需要O(n^2)的时间复杂度。是一种以时间换空间的做法，通常空间不为瓶颈时，应采用 效率更高的非原地归并排序。</p>
<h5 id="自顶向下（递归）非原地归并"><a href="#自顶向下（递归）非原地归并" class="headerlink" title="自顶向下（递归）非原地归并"></a>自顶向下（递归）非原地归并</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] <span class="built_in">mergeSort</span>(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="type">int</span>[] tmpArr = <span class="keyword">new</span> <span class="type">int</span>[arr.length];</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr, tmpArr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// mergeSort 递归方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] tmpArr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> c = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, tmpArr, l, c);</span><br><span class="line">        <span class="built_in">mergeSort</span>(arr, tmpArr, c + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">merge</span>(arr, tmpArr, l, c, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非原地合并方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] tmpArr, <span class="type">int</span> l, <span class="type">int</span> c, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lh = l, rh = c + <span class="number">1</span>, h = l; <span class="comment">// lh: left head, rh: right head, h: tmpArr head</span></span><br><span class="line">    <span class="keyword">while</span> (lh &lt;= c &amp;&amp; rh &lt;= r) &#123;</span><br><span class="line">        tmpArr[h++] = arr[lh] &lt;= arr[rh] ? arr[lh++] : arr[rh++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (lh &lt;= c) tmpArr[h++] = arr[lh++]; <span class="comment">// 左半边还有剩余，加入 tmpArr 末尾</span></span><br><span class="line">    <span class="keyword">while</span> (rh &lt;= r) tmpArr[h++] = arr[rh++]; <span class="comment">// 右半边还有剩余，加入 tmpArr 末尾</span></span><br><span class="line">    <span class="keyword">for</span>(; l &lt;= r; l++) arr[l] = tmpArr[l]; <span class="comment">// 将 tmpArr 拷回 arr 中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="时间复杂度O-n-级别排序"><a href="#时间复杂度O-n-级别排序" class="headerlink" title="时间复杂度O(n)级别排序"></a>时间复杂度O(n)级别排序</h3><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://quercussprings.github.io/2024/02/20/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/" data-id="cm5kj5st0000e7ov90tz24xhd" data-title="leetbook算法笔记（三）排序专题" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" rel="tag">归并排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" rel="tag">快速排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-leetbook笔记（二）链表、队列和栈" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/18/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E9%93%BE%E8%A1%A8%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/" class="article-date">
  <time class="dt-published" datetime="2024-02-18T12:05:07.000Z" itemprop="datePublished">2024-02-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/18/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E9%93%BE%E8%A1%A8%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/">leetbook算法笔记（二）链表、队列和栈</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2></li>
</ul>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul>
<li><p>单链表的每个结点不仅包含值，还包含到下一个结点的引用字段</p>
<ul>
<li>&#96;&#96;&#96;c++<br>&#x2F;&#x2F;单链表中结点的典型定义 C++ style<br>struct SinglyListNode{<br>int val;<br>SinglyListNode *next;<br>&#x2F;&#x2F;构造函数冒号后直接接初始化参数<br>SinglyListNode(int x) : val(x), next(NULL) {}<br>};<br>&#x2F;&#x2F;C style<br>typedef struct List{<br>int data;<br>struct List *next;<br>}List, *LIST;	&#x2F;&#x2F;struct List &#x3D;&gt; List <em>xxx ||struct List</em>&#x3D;&gt; LIST xxx<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 与数组不同，我们无法在常量时间内访问单链表中的随机元素，必须从头结点开始逐个遍历。即为花费O(N)时间。</span><br><span class="line"></span><br><span class="line">#### 添加操作</span><br><span class="line"></span><br><span class="line">- 最简单一句话思路：**先让新来的结点有所指向**</span><br><span class="line">  - ![image-20240118100036608](.\leetbook笔记（二）链表、队列和栈\image-20240118100036608.png)</span><br><span class="line">- 我们用头结点代表整个链表，在开头添加结点须要：</span><br><span class="line">  1. 初始化新结点cur</span><br><span class="line">  2. 新结点连接到原始头结点head</span><br><span class="line">  3. 将cur指定为head</span><br><span class="line"></span><br><span class="line"> ```c++</span><br><span class="line">  //中间插入结点</span><br><span class="line">  singlyListNode cur = new singlyListNode(val,next);</span><br><span class="line">  cur.Next=prev.next;</span><br><span class="line">  prev.next=cur;</span><br><span class="line">  //开头添加结点</span><br><span class="line">  singlyListNode cur = new singlyListNode(val,next);</span><br><span class="line">  cur.next=head;</span><br><span class="line">  head=cur;</span><br><span class="line">  //结尾添加结点</span><br><span class="line">  while(cur.next!=null)&#123;</span><br><span class="line">      cur=cur.next;</span><br><span class="line">  &#125;</span><br><span class="line">  cur.next=newNode;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><ul>
<li><p>删除中间结点</p>
<ol>
<li>找到cur的上一个结点prev及其下一个结点next</li>
<li>连接prev到cur的下一个结点next</li>
</ol>
</li>
<li><p>删除第一结点</p>
<ol>
<li>直接将下一个结点分配为head结点</li>
</ol>
</li>
<li><p>删除最后结点</p>
<ol>
<li>置倒数第二个结点的后继指针为空</li>
</ol>
</li>
</ul>
<h4 id="链表中的双指针"><a href="#链表中的双指针" class="headerlink" title="链表中的双指针"></a>链表中的双指针</h4><ul>
<li>快慢指针判断是否有环</li>
</ul>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize slow &amp; fast pointers</span></span><br><span class="line">ListNode* slow = head;</span><br><span class="line">ListNode* fast = head;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Change this condition to fit specific problem.</span></span><br><span class="line"><span class="comment"> * Attention: remember to avoid null-pointer error</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">while</span> (slow &amp;&amp; fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">    slow = slow-&gt;next;          <span class="comment">// move slow pointer one step each time</span></span><br><span class="line">    fast = fast-&gt;next-&gt;next;    <span class="comment">// move fast pointer two steps each time</span></span><br><span class="line">    <span class="keyword">if</span> (slow == fast) &#123;         <span class="comment">// change this condition to fit specific problem</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// change return value to fit specific problem</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>D&#x3D;(N-1)(S1+S2)+S2</p>
</li>
<li><p>首次相遇后，慢指针不动。将快指针倒回首结点，和慢指针同速，再相遇即为入环点</p>
</li>
</ul>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><ul>
<li><p>方案一：按原始顺序迭代结点，并将它们逐个移动到列表头部</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        prev-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = dummy-&gt;next;</span><br><span class="line">        dummy-&gt;next = cur;</span><br><span class="line">        cur = prev-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><h2 id="队列与栈"><a href="#队列与栈" class="headerlink" title="队列与栈"></a>队列与栈</h2><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li>队列是先入先出（FIFO）的数据结构，插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。 删除（delete）操作也被称为出队（dequeue)。 只能移除第一个元素。</li>
</ul>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//队列应支持两种操作，入队和出队，需要一个索引指出起点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 数据域</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; data;       </span><br><span class="line">        <span class="comment">// 起点</span></span><br><span class="line">        <span class="type">int</span> p_start;            </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MyQueue</span>() &#123;p_start = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="comment">//先入先出，入队时起点不变</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">            data.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出队时，先入先出，即起点后移</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p_start++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//得到起点</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data[p_start];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//检查队列是否空</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p_start &gt;= data.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyQueue q;</span><br><span class="line">    q.<span class="built_in">enQueue</span>(<span class="number">5</span>);</span><br><span class="line">    q.<span class="built_in">enQueue</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (!q.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">Front</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">deQueue</span>();</span><br><span class="line">    <span class="keyword">if</span> (!q.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">Front</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">deQueue</span>();</span><br><span class="line">    <span class="keyword">if</span> (!q.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">Front</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随着出队即起始指针的移动，浪费了越来越多的空间。 当我们有空间限制时，这将是难以接受的。这就需要循环队列。</span></span><br></pre></td></tr></table></figure>

<h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularQueue</span> &#123;</span><br><span class="line">    <span class="comment">//一队头索引，一队尾索引</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    <span class="type">int</span> p_start;</span><br><span class="line">    <span class="type">int</span> p_last;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyCircularQueue</span>(<span class="type">int</span> k) &#123;</span><br><span class="line">        data.<span class="built_in">resize</span>(k);</span><br><span class="line">        <span class="comment">//队列为空状态</span></span><br><span class="line">        p_start=<span class="number">-1</span>;</span><br><span class="line">        p_last=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入队，先入先出，队头不变，队尾+1</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            p_start++;</span><br><span class="line">            p_last++;</span><br><span class="line">            data[p_last] = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isFull</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//通过+1和队列长度求余数，来循环。关键一步。</span></span><br><span class="line">        p_last = (p_last + <span class="number">1</span>) % data.<span class="built_in">size</span>();</span><br><span class="line">        data[p_last] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出队，先入先出，队头+1队尾不变</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p_start == p_last) &#123;</span><br><span class="line">            p_start = <span class="number">-1</span>;</span><br><span class="line">            p_last = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p_start = (p_start + <span class="number">1</span>) % data.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> data[p_start];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> data[p_last];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p_start == <span class="number">-1</span> &amp;&amp; p_last == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((p_last + <span class="number">1</span>) % data.<span class="built_in">size</span>() == p_start) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="队列与广度优先搜索"><a href="#队列与广度优先搜索" class="headerlink" title="队列与广度优先搜索"></a>队列与广度优先搜索</h4><p>  BFS通过队列实现，关于树的层序遍历见 树-树的遍历-层序遍历。更多可见广度优先搜索专题。</p>
<h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>栈是后入先出（LIFO）的数据结构</li>
</ul>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可用可变数组实现堆栈结构 could use variable-array </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data; <span class="comment">//store elements</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 常用函数 判空 判顶 压栈 出栈</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        data.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="栈与深度优先搜索"><a href="#栈与深度优先搜索" class="headerlink" title="栈与深度优先搜索"></a>栈与深度优先搜索</h4><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://quercussprings.github.io/2024/02/18/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E9%93%BE%E8%A1%A8%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/" data-id="cm5kj5sst00017ov9dq25ct5g" data-title="leetbook算法笔记（二）链表、队列和栈" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-leetbook笔记（一）程序模拟、数组和字符串 " class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/15/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%20/" class="article-date">
  <time class="dt-published" datetime="2024-02-15T10:41:51.000Z" itemprop="datePublished">2024-02-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/15/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%20/">leetbook算法笔记（二）链表、队列和栈</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="程序模拟"><a href="#程序模拟" class="headerlink" title="程序模拟"></a>程序模拟</h2><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>模拟就是用计算机来模拟题目中要求的操作。</p>
<p>模拟题目通常具有码量大、操作多、思路繁复的特点。由于它码量大，经常会出现难以查错的情况，如果在考试中写错是相当浪费时间的。</p>
<p>写模拟题时，遵循以下的建议有可能会提升做题速度：</p>
<ul>
<li>在动手写代码之前，在草纸上尽可能地写好要实现的<strong>流程</strong>。</li>
<li>在代码中，尽量把<strong>每个部分模块化</strong>，写成函数、结构体或类。</li>
<li>对于一些可能重复用到的概念，可以统一转化，方便处理：如，某题给你 “YY-MM-DD 时：分” 把它抽取到一个函数，处理成秒，会减少概念混淆。</li>
<li>调试时分块调试。模块化的好处就是可以方便的单独调某一部分。</li>
<li>写代码的时候一定要<strong>思路清晰</strong>，不要想到什么写什么，要按照落在纸上的步骤写。</li>
</ul>
<p>实际上，上述步骤在解决其它类型的题目时也是很有帮助的。</p>
<h2 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>读取<ul>
<li>时间复杂度O(1)</li>
<li>直接访问索引，取值</li>
</ul>
</li>
<li>查找<ul>
<li>时间复杂度O(N)</li>
<li>逐步读取，逐步比较，相同则取出</li>
</ul>
</li>
<li>插入<ul>
<li>索引，后移腾空，插入</li>
</ul>
</li>
<li>删除<ul>
<li>索引，删除，向前填补</li>
</ul>
</li>
</ul>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><ul>
<li>二维数组存储空间<strong>连续</strong></li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li>比较</li>
<li>连接</li>
</ul>
<h4 id="字符串匹配算法KMP"><a href="#字符串匹配算法KMP" class="headerlink" title="字符串匹配算法KMP"></a>字符串匹配算法KMP</h4><ul>
<li><p>目标：在一个字符串中匹配一个子串</p>
</li>
<li><p>时间复杂度O(m+n)</p>
</li>
<li><p>关键思路：在信息不匹配的时候，由于已经遍历过主串部分字符，可利用这些信息避免主串指针回退。换句话说，不递减主串的指针。</p>
<ul>
<li>&#96;&#96;&#96;c++<br>int match (char* P, char* S){ &#x2F;&#x2F; KMP 算法<br>int* next &#x3D; buildNext(P); &#x2F;&#x2F; 构造 next 表<br>int m &#x3D; (int) strlen(S), i &#x3D; 0; &#x2F;&#x2F; 文本串指针<br>int n &#x3D; (int) strlen(P), j &#x3D; 0; &#x2F;&#x2F;模式串指针<br>while (j &lt; n &amp;&amp; i &lt; m) &#x2F;&#x2F; 自左向右逐个比对字符<br>    if (0 &gt; j || S[i] &#x3D;&#x3D; P[j]) &#x2F;&#x2F; 若匹配，或 P 已移除最左侧<br>        {i++; j++;} &#x2F;&#x2F; 则转到下一字符<br>    else<br>        j &#x3D; next[j]; &#x2F;&#x2F; 模式串右移（注意：文本串不用回退）<br>delete [] next; &#x2F;&#x2F; 释放 next 表<br>return i - j;<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- 关键问题：再比对时，怎么知道要跳过多少字符呢</span><br><span class="line"></span><br><span class="line">  - 通过next数组，最后一个匹配的字符所对应的next数值即为子串中跳过匹配字符的个数</span><br><span class="line"></span><br><span class="line">  - next数组本质是记录子串共同前后缀的长度</span><br><span class="line"></span><br><span class="line">    - ```伪代码</span><br><span class="line">      //buildNext</span><br><span class="line">      while(i小于数组长度)&#123;</span><br><span class="line">      	if (共同前后缀最后字符==该字符)&#123;</span><br><span class="line">      		共同前后缀长度+=1;</span><br><span class="line">      		next数组追加(共同前后缀长度);</span><br><span class="line">      		i+=1;</span><br><span class="line">      	&#125;else&#123;</span><br><span class="line">      		if(共同前后缀长度==0)&#123;</span><br><span class="line">      			next数组追加(0);</span><br><span class="line">      			i+=1;</span><br><span class="line">      		&#125;else&#123;</span><br><span class="line">      			//减小前后缀长度查看存不存在更短的前后缀</span><br><span class="line">      			共同前后缀长度 = next[共同前后缀长度-1]</span><br><span class="line">      		&#125;</span><br><span class="line">      	&#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="双指针思想"><a href="#双指针思想" class="headerlink" title="双指针思想"></a>双指针思想</h3><h4 id="始末指针"><a href="#始末指针" class="headerlink" title="始末指针"></a>始末指针</h4><ul>
<li>使用始末指针的典型场景，是要从两端向中间迭代数组</li>
<li>退出条件一般是头指针&lt;尾指针</li>
</ul>
<h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><ul>
<li>两指针不同步，即为快指针无条件移动，慢指针有条件移动，或快指针移动条件松于慢指针。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://quercussprings.github.io/2024/02/15/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%20/" data-id="cm5kj5ssp00007ov92qwmhjbw" data-title="leetbook算法笔记（二）链表、队列和栈" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag">基础知识</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-渲染方程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-12-18T15:21:15.000Z" itemprop="datePublished">2021-12-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91%E4%B8%8E%E7%AC%94%E8%AE%B0/">文章翻译与笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/">《The Rendering Equation》简译</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="admonition info"><p class="admonition-title">信息  
</p><p>这是一篇经典论文，在其思想深刻影响后世的同时，部分表述已不再流行。</p>
</div>

<div class="admonition attention"><p class="admonition-title">注意  
</p><p>因水平有限，本翻译部分参考机翻。并只进行了简单校对，未有精校，或有错译现象。
此文本仅供参考。</p>
</div>

<h1 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h1><h5 id="SIGGRAPH-1986-1986-4"><a href="#SIGGRAPH-1986-1986-4" class="headerlink" title="SIGGRAPH 1986(1986.4)"></a>SIGGRAPH 1986(1986.4)</h5><h5 id="James-T-Kajiya"><a href="#James-T-Kajiya" class="headerlink" title="James T. Kajiya"></a>James T. Kajiya</h5><h5 id="加州理工学院"><a href="#加州理工学院" class="headerlink" title="加州理工学院"></a>加州理工学院</h5><p><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/THE%20RENDERING%20EQUATION0001.png" alt="ACM SIGGRAPH Computer Graphics, Volume 20, Issue 4, Aug. 1986, pp. 143–150, https://doi.org/10.1145/15886.15902, Title:The Rendering Equation"></p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>我们提出了一个集已知的渲染算法之大成的积分方程。在讨论用蒙特卡洛法解决此问题时，我们也提出了一种新的样本方差减少方法，其称为“分层采样法”，并给出了有关此方法的详细阐述。由此产生的渲染算法扩展了可以有效模拟的光学现象的范围。</p>
<h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>计算机图形学，光栅化，光线追踪，辐射度量学，蒙特卡洛法，分布式光线追踪，方差消减。</p>
<h2 id="渲染方程-1"><a href="#渲染方程-1" class="headerlink" title="渲染方程"></a>渲染方程</h2><p>我们提出的技术涵盖了各种各样的渲染算法，并提供了一个统一的研究背景，以便于可以将之前各式的算法视作这一方程的各种近似。一旦意识到所有的渲染方法都试图模拟相同的物理现象，即光在各种表面散射（译注：此处及下文的散射是广义的，反射和折射都是弹性散射。不过未经专门说明，将这些”散射”理解为漫反射是更简单的方法）的现象，就不会对形形色色的渲染方法能归于一式感到惊讶了。  </p>
<p>对我们所提的渲染方程，其背后的想法已不新鲜。对这个方程所模拟的现象的描述，在辐射传导领域中已经研究了数年[Siegel , Howell 1981]。然而，我们提出的这个很适合于计算机图形学的方程形式，在以前却未出现过。  </p>
<p>渲染方程为<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B.png" alt="渲染方程"><br>其中：I(x, x’)  约束了从x’到x点的辐射强度<br>g(x, x’)  是几何分量<br>e(x, x’)  约束了从x’到x点的自发光强度<br>ρ(x, x’,x’’)  约束了一定表面上散射光的强度</p>
<p>这个方程非常符合辐射度量学方程的精神，只是简洁地平衡了从单一表面的一个点到另一个点的能量。该方程指出，从一个点到另一个点的光的传输强度只是自发光和从所有其他表面点散射到该点的总的光强度之和。方程(1)与辐射度量学方程的不同之处在于，没有对相关表面的反射特性作出假设。  </p>
<p>对方程中每一个量，我们都暂称为“非闭合的多重传输量”。我们将在第二节逐个给出定义并将其与·辐射度量学联系起来。 </p>
<p>该积分的积分域是在所有几何表面上，因此点x、x’、x’’的范围也是在此域中。不仅如此，还有定义了背景表面S0，其是一个足够大的半球，能够作为整个模型完全的包围圈。需要指出的是，该包围半球的正半球涵盖光线可能的所有反射域，负半球涵盖了光线可能的所有传输域。</p>
<p>作为麦克斯韦电磁方程的一个近似模拟，(1)并没有模拟所有有趣的光学现象。(1)并不试图对所有光学现象进行建模，它基本上是一个几何光学近似。我们只建立了时间平均传输强度的模型，因此在这个方程中没有考虑到辐射相位————即排除了对衍射的任何处理。我们还假设了不同介质表面之间是均匀的折射率，并且本身不参与散射光。后两种情况可以通过公式(1)的成对归纳来处理，在第一种情况下，只需让g(x, x’)考虑到具有非均质折射率的介质以处理光程。对于参与传播的介<br>质，需要一个整数微分方程。其拓展延伸也是众所周知的，见[Chandraseka.r 1950]，以及用于计算机图形应用的[Kajiya and von Herzen 1984]。处理不同介质光程的合理方式，哈密顿-雅可比方程[Goldstein 1950]，至少在一个世纪前就有了，对参与介质以及相位和衍射的处理可以被其处理。关于这些与各种物理现象有关的光学拓展方法，见[Feynman and Hibbs 1965]。最后，公式(1)中确实没有提到波长或偏振的相关性质。而考虑波长和偏振却是理所应当的。  </p>
<h2 id="对传输量的论述"><a href="#对传输量的论述" class="headerlink" title="对传输量的论述"></a>对传输量的论述</h2><p>在此我们讨论方程（1）的每个物理量和数学项。<br>这个方程描述了一个简化模型的光线传输过程。我们将把I(x,x’)命名为从x’到x的非闭合的两点辐射强度，或者更简洁地称其为辐射强度。辐射强度I( x, x’) 是单位时间单位区域dx’向dx的辐射能量。<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/2.png" alt="辐射强度"><br>I的单位是瓦特每球面度每平方米。  </p>
<p>数学量g(x, x’) 是一个几何项，这个项对表面点被其他表面点遮挡的情况进行标记。如果在场景中，x’和x实际上不是相互可见的，那么这个几何项就是0。另一方面，如果它们彼此可见，那么这个项就是1&#x2F;r2，其中r是x’到x的距离。注意到，一个闭合的完全透明的表面可以使g(x, x’)等于0。因为事实上，透明的表面截留了辐射的反射能量，并将其重新折射到另一边。  </p>
<p>自发光项e(x, x’)，其测量的是发出于x’点到达x点的能量。我们称其为“非闭合的自发光转移量”。它给定了单位时间单位面积的光源到达目标单位面积的能量，亦即：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/3.png" alt="自发光项e"><br>其单位为瓦特每平方米。 </p>
<p>最后，辐射率ρ(x, x’, x”)是由x’处的表面辐射出的能量强度，从x”方向的入射光线开始，到x方向的出射光线结束。我们将称它为“从x “到x’处的非闭合的辐射率”。所以到达x的能量是：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/4.png" alt="辐射率"><br>其单位为瓦特每球面度每平方米。  </p>
<p>现在我们把传输量与更常规的辐射度量学联系起来。我们将通过在给定的数学几何模型中，论述能量传输模型中的每个量来实现这一点。 </p>
<p>通用辐射度量模型中的辐射强度（译注：光学上称发光强度）定义为每单位时间每单位投射面积的能量，即：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/5.png" alt="辐射能量_度量学">  </p>
<p>由几何模型可知：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/6.png" alt="立体角推导"><br>其中：向量n是表面dx的法向量<br>向量n’是表面dx’的法向量<br>向量t’是表面dx’的切向量<br>标量r 是x’ 到x 的距离  </p>
<p>一个表面项dx所对应的立体角是半径为r的球体被dx的球面投影面积dxp所占据的面积。即：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/7.png" alt="立体角公式">  </p>
<p>那么，将公式(7)带入到公式(5)能够得到：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/8.png" alt="辐射能量_立体角">   </p>
<p>公式(2)和公式(5)的比较能给出我们定义的辐射强度这一传输量和通用辐射度量学的关系：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/9.png" alt="辐射强度_度量学">  </p>
<p>自发光项与通用辐射度量学的关系也是这样得到的。假设有非闭合的表面，从dx’到dx的自发光分量，由公式(3)定义。通过如上引入立体角的流程，我们可以得到：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/10.png" alt="自发光_度量学">  </p>
<p>最后，我们将传输量中的反射率与通用辐射度量学中的双向反射函数ρ(θ’, φ’, ψ’, σ’)联系起来，从定义来看：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/11.png" alt="BRF">  </p>
<p>我们除了能得到方程(6)和(7)外，还可得到以下内容：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/12.png" alt="BRF_几何量"><br>其中：<br>向量n’’ 是表面dx’’的法线向量<br>标量r’’ 是x’’到x’的距离<br>dω’’为基于dx’’的立体角<br>结合公式(2)、(8)、(9)、(11)和(12)，我们可以得到非闭合的考虑三点的双向反射函数定义：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/13.png" alt="BRF_定义">  </p>
<h2 id="诸近似求解法"><a href="#诸近似求解法" class="headerlink" title="诸近似求解法"></a>诸近似求解法</h2><p>在本节中，我们将回顾渲染方程的近似解法。这些近似解法表明，各种渲染算法都可以在这个渲染方程提供的统一背景下进行研究。在讨论的过程中，读者可能会想到许多其他未曾尝试过的近似解法。我们鼓励研究者在这个领域开展更多的工作。这个领域在很大程度上还未被探索，因为目前的大部分努力只集中在下面要介绍的诸解决方法上。  </p>
<h3 id="诺伊曼级数"><a href="#诺伊曼级数" class="headerlink" title="诺伊曼级数"></a>诺伊曼级数</h3><p>解决像公式(1)这样的积分方程的一种方法来自一个众所周知的形式化操作，见[Courant and Hilbert 1953]。我们可将其改写为如下形式:<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/Neumann_a.png" alt="诺伊曼_a"><br>其中M是由公式(l)中的积分所给出的线性算子。现在，我们可把这个方程改写为：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/Neumann_b.png" alt="诺伊曼_b"><br>其中1是单位算子，由此我们可以通过以下方式形式地反转该等式：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/Neumann_c.png" alt="诺伊曼_c"><br>该无限级数收敛的一个条件是算子M的谱半径小于1。(在我们讨论的情况下，这一点是可以满足的）。对诺伊曼级数展开的物理解释同样吸引我们。它描述了辐射传输模型的辐射强度实质上是直接光照项、一次散射项、二次散射项、与以此类推的多次散射项之和。  </p>
<h3 id="犹他近似"><a href="#犹他近似" class="headerlink" title="犹他近似"></a>犹他近似</h3><p>由于缺乏更好的说法，我们将直接把渲染着色表面的经典方法称为犹他近似法（译注：实际上这是后世所称Blinn-Phong经验模型的数学物理依据）。在这种近似法中我们直接用两项之和来近似辐射强度I：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/utah.png" alt="犹他近似"><br>能看到，犹他近似法忽略除了一次散射外所有的散射，到目前为止，几何项成为最难计算的项。Utah近似法只对最终散射进入眼睛的g项进行计算。当然，这就成为由犹他大学的许多早期研究人员研究的经典的隐藏面问题。请注意，在第二项中，算子M不在ge上操作，而是在直接影响e0。因此，这个近似值忽略了自发光的可见性，亦即忽略了阴影。e0项意味着只考虑单一点光源。没有考虑扩展的其他照明表面。这种简化将算子M简化为对点光源的一个有限规模的求和，而不是对整个投射光域x’’的积分。  </p>
<p>从那时起，出现了许多拓展算法，最引人注目的是阴影处理算法和扩展光源种类的工作。  </p>
<h3 id="光线追踪算法"><a href="#光线追踪算法" class="headerlink" title="光线追踪算法"></a>光线追踪算法</h3><p>Whitted[1980]，提出了一个不同于前的近似方法：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/whitted.png" alt="光线追踪"><br>在这一著名的近似中， M0是一个散射模型，它是两个delta函数和一余弦项的总和。这两个delta函数代表了他照明模型中的反射和折射，余弦项代表漫反射成分。应注意，他考虑到了ge0亦即阴影，但仍然是处于点光源下的情况。Whitted的环境光项直接来自e项。 同样的，算子M是一个有限规模求和。  </p>
<h3 id="随机光线追踪算法"><a href="#随机光线追踪算法" class="headerlink" title="随机光线追踪算法"></a>随机光线追踪算法</h3><p>1984年，Cook[Cook et al 1984]，引入了随机光线追踪算法。这种近似方法是了具有三部分的Whitted模型的扩展，从而产生了一个更精确的散射模型。这一扩展使得在计算算子M时，对积分的估值变得必要。在这个模型中，M是由反射和折射delta函数的分布估值来近似表示的。使之成为可能的创新是使用蒙特卡洛法来进行积分数值估计。众所周知，估计积分数值的能力广泛地扩展了可被分析的光学现象其范围。<br>然而，对于随机光线追踪来说，对环境光项的适当处理仍然难以实现。  </p>
<h3 id="辐射度方法"><a href="#辐射度方法" class="headerlink" title="辐射度方法"></a>辐射度方法</h3><p>1984年，Cohen md Greenburg 在计算机图形学领域引入了辐射度方法，这是一项重要的新型渲染技术。它可以处理理想漫反射表面的能量平衡。也就是说平滑表面遵守如下的双向反射函数。<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/14.png" alt="辐射度方法"><br>定义在表面dx’的辐射度B(x’) 是整个可见半球的辐射通量。它是单位时间内单位（未经投影的）区域的能量，单位瓦特每平方米。定义是<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/15.png" alt="辐射度"><br>由此，为了计算半球域上的所有辐射量，我们可以简单地对场景中的所有表面进行积分。故，从公式(1)和(15)中我们可以得到：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/16.png" alt="辐射度_联系几何量"><br>如果x和x’之间存在遮挡，那么自发光项的贡献为零。否则，其贡献为：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/17.png" alt="辐射度_联系球面度"><br>其中e0是基于表面元素dx’的半球形辐照度。<br>同样，对于反射项，若表面被遮挡，则反射项对辐射度的贡献也是零。未被遮挡时，我们会得到：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/18.png" alt="辐射度_联系球面度"><br>其中H是单位时间内单位面积的半球域中入射的能量。 在这个推导中，我们转换了积分的顺序，并使用了(13)、(12)和(14)的特征。现在使用方程(17)和(18)，再基于(16)，我们能看到，渲染方程变为：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/19.png" alt="辐射度_结果"><br>这就是Goral等人推导出的公式(4) [1984]  </p>
<p>计算积分的辐射强度H对于计算辐射率中最终的Fij矩阵至关重要。这需要进行可见度计算，这可能是相当耗时的。由于矩阵方程是通过一些松弛迭代步骤来解决的，它基本上等同于对诺伊曼级数的前几项进行求和，即自发光量传播四次左右的散射量。使用松弛法需要计算全部的矩阵。松弛法还可以提供场景中所有表面的所有辐射强度。虽然在某些情况下，这可能是一个优势，但使用下面概述的蒙特卡洛方法可能更为先进。  </p>
<h2 id="马尔可夫链求解积分方程"><a href="#马尔可夫链求解积分方程" class="headerlink" title="马尔可夫链求解积分方程"></a>马尔可夫链求解积分方程</h2><p>马尔科夫链的使用可能是解决积分方程的最流行的数值方法。 它被广泛应用于队列论和中子迁移等领域。事实上，在辐射传导中使用马尔科夫链蒙特卡洛法已经有一段时间了[Siegel, Howell 1981]。在热传导方法中，一个特定波长的辐射量从某个特定表面中发射、反射和吸收。计算每个表面吸收的辐射量，依据于几何因素的估算，而精确的计算将是一个难以解决的问题。这类似于从光源到眼睛的光线追踪。但我们不采用这些方法，而是选择更直接地解决公式(1)，回到von Neumann 和 Ulam首次提出的早期蒙特卡洛方法[Rubenstein 1981]  </p>
<h3 id="有限空间求解"><a href="#有限空间求解" class="headerlink" title="有限空间求解"></a>有限空间求解</h3><p>作为介绍，我们首先在一个有限元的背景下介绍这个方法。这简化了符号，并使所涉及的基本思想变得明显。我们再一次注意到，这个例子中的方法可能比目前流行的辐射度松弛方案有很多优势：只需要计算可见点的辐射度，而整个辐射度矩阵的计算可以换成非常有限的一组选定矩阵元素。  </p>
<p>假设我们希望解决矢量方程：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/MCMC_0.png" alt="MCMC_0"><br>其中x和a是n维向量，x是未知量，且M&#x3D;(m_ij)是n×n的矩阵。<br>现在从诺伊曼拓展中我们可以看到，对于矩阵M来说，特征值处于单位圆范围内的。x的解法由下公式给出：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/MCMC_1.png" alt="MCMC_1"><br>该方法通过矩阵乘法的路径平均对积分求积。亦即它依靠逐矩阵行和矩阵列的路径，构成一个迭代的矩阵乘积。对于路径中的每个点我们得到一系列行或列，可以用一个从1到n的整数来索引。  </p>
<p>构建一个概率空间O，其中每个样本ω是在每个离散时间内访问n个点之一的路径，即 ω &#x3D;（n0，n1，…，n），对其中的每个n，都是1至n的正整数。对于路径ω的度量量k&#x3D;l(ω)是有限的，但在其他方面是任意且一致的，并对应于k级矩阵幂。每条路径都被分配了一个概率p(ω)<br>如果我们想计算x的一个坐标值，记作x1，其值计算如下：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/MCMC_2.png" alt="MCMC_2"><br>对于所有路径的平均ω∈Ω，简单地取期望就可以得到这个量预期的量。  </p>
<p>路径的概率空间更加容易用马尔科夫链来构建。一个（静态的）离散马尔可夫链包括一组状态X，以及从一个状态x’∈X 到另一个状态x∈X的过渡概率p(x, x’)，还有一个初始状态的概率密度p(x)。一些状态的子集可以被指定为吸收态，即不允许从吸收态中转换出来。   </p>
<p>马尔可夫链产生的路径的概率是初始状态和所有过渡概率的积，直到达到一个吸收状态为止。因此，对于一条路径：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/MCMC_3.png" alt="MCMC_2"><br>有n-阶马尔可夫链路径概率：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/MCMC_4.png" alt="MCMC_2"><br>在有限维度的情况下，我们让马尔科夫链的状态集作为向量或矩阵的索引集，即X &#x3D; {1, … , n}。理应注意，尽管我们在选择过渡概率时是宽容的，但与非零状态对应的过渡概率必须是非负的。我们对积分解的估值极限完全独立于路径的概率分布，但收敛到极限的速度在很大程度上取决于选择过渡概率的方式。第5节给出了一套选择过渡概率的新方法。</p>
<h3 id="无限空间求解"><a href="#无限空间求解" class="headerlink" title="无限空间求解"></a>无限空间求解</h3><p>将马尔科夫链蒙特卡洛方法扩展到无限维度空间是很简单的。对于眼前的积分方程，我们注意到它是第二类弗雷德霍姆积分方程的变体。表面在反射和透射方面的无源被动性保证了诺伊曼级数的收敛。我们只需用表面上的点x的集合来代替状态集，计算这些点的流程程序如下：  </p>
<ol>
<li>在场景中选择一个通过视口可见的点x’到视口上选定的像素x。  </li>
<li>加上辐射强度。  </li>
<li>对于马尔可夫链路径中的度量<br>3.1 选择点x’’并计算几何因子g(x,x’’)。<br>3.2 计算反射率ρ(x, x’, x’’) 并乘以e(x’, x”)。<br>3.3 将这一结果加入到像素辐射强度中。</li>
</ol>
<p>应知，计算辐照度和散射系数仅仅是计算纹理贴图和光照模型的问题。计算几何因子实际上就是光线追踪的光线对象求交。还要注意的是，通过以选定的角度射出射线并找到最近的交点来选择马尔可夫路径上的下一个点x’’，我们实际上是在进行有效的重要性采样优化。也就是说，我们不需要计算另两个闭塞点x’, x’’的积分，因为我们知道这个积分将是零。这与辐射度算法中的松弛过程相反，后者总是从所有表面获取能量贡献。  </p>
<h2 id="分层采样"><a href="#分层采样" class="headerlink" title="分层采样"></a>分层采样</h2><p>我们现在提出了一些新的减少方差的技术，以解决渲染方程的问题。然而，我们必须指出，这里所指出的技术能够应用的范围要广得多。一般来说，它们对积分特别困难的各种蒙特卡罗积分问题都有帮助。在这种情况下，比以前已知的方法所多增加的开销都变得可以忽略不计。我们提出了五种方法，它们越来越多地利用了有价值的被积样本的优点。下面概述的所有技术都受到分层抽样的启发。  </p>
<h3 id="序列一致采样"><a href="#序列一致采样" class="headerlink" title="序列一致采样"></a>序列一致采样</h3><p>第一种采样技术源于一种常见的顺序抽样策略。通常情况下，积<br>分的样本被反复收集，直到积分估计的样本方差低于一个固定的<br>阈值。这种策略在[Lee, Redner and Uselton 1985]中被证明是有优势的，他们在图像的感兴趣部分收集到了许多样本，同时在不感兴趣的部分收集到的样本则很少。  </p>
<p>不幸的是，这种顺序策略与分层采样并不兼容。在分层采样技术中，感兴趣的领域被划分为子单元。Lee使用每像素8个单元的固定细分，并在每个单元内随机抽取样本。理想情况下。当每个均匀划分单元收集一个样本时，可以获得更好的收敛性。这就是所谓的抖动采样方法。通常我们认为单元的中心形成一个网格。顺序取样<br>和抖动取样之间的不相容性是由于在精确知道将采集多少个样本<br>之前，不可能对采样域进行均匀的细分。  </p>
<p>顺序均匀取样是通过保持一棵不同大小的单元树来实现的。不同大小的单元。每次取样时，首先选择一个单元，然后再分成若干单元。原始单元的旧样本必须在一个新的子单元中。新的样本则被选在相反的单元中。一个简单的图示将说明这一技术。<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/HS_0.png" alt="SUS">   </p>
<p>为了投射一个新的样本点，我们遍历树，直到遇到一个未访问的叶子单元。然后我们把叶子单元分成两半，把样本投到空的那一半单元。  </p>
<ol>
<li>如果该节点是一个内部节点<br>1.1 选择一个子节点<br>1.2 完善所选择的子节点<br>1.3 返回  </li>
<li>否则，分割叶子节点  </li>
<li>将旧样本传播到包含它的子叶中。  </li>
<li>在剩余的空子叶上投下一个新样本</li>
</ol>
<p>我们怎样才能保证进行尽可能均匀的细分？一种方法是以广度优先的顺序遍历采样树。在分割更深的节点之前，在每一级都分割一个叶子节点。这种策略产生了高度有序的样本分布，基本上是在区间内扫描。一个更好的方法是以随机顺序广度优先分割节点。以下流程体现了这种规划策略。  </p>
<ol>
<li>如果其中一个是叶子，就选择它。  </li>
<li>如果层(左)&lt;层(右)且左边是平衡的，选择左边的节点。  </li>
<li>如果层(右)&lt;层(左)且右是平衡的，选择右边的节点。  </li>
<li>否则就随机选择。</li>
</ol>
<p>请注意，这个策略实际上是在整个区间内进行随机搜索，而不是<br>集中在任何特定区域。  </p>
<h3 id="多重维度情况"><a href="#多重维度情况" class="headerlink" title="多重维度情况"></a>多重维度情况</h3><p>上述算法很容易扩展到更高的维度，只需使用一种由Bentley[Bentley 1979]提出的被称为K-D树的数据结构即可。在这种数据结构中，域被一个垂直于连续共轴的超平面连续地分成两半。因此，对于一个单位区域，k-d树首先沿着垂直线进行细分，然后在下一级沿着水平线进行细分。上述统一的子节点选择规则确保了统一的细分，不需要任何修改。对路径空间的推广是直接的。  </p>
<h3 id="分层整合"><a href="#分层整合" class="headerlink" title="分层整合"></a>分层整合</h3><p>上述技术的第三个版本利用了以下事实。每个样本的单元都样本本身的记录。在这种情况下我们就可以计算出一个黎曼和，用单元的大小和样本的值作为积分。Yakowitz [Yakowit et al 1978]提出了这种方法的一个变体（使用样本本身作为边界点，没有分层）。他发现在一维中的方差为O(n^-4)，而在二维中的方差为O(n^-2)。这大大优于O(n^-1)的简单蒙特卡洛法。我们的技术分析仍在进行中并将出现在一篇配套的论文中。但依据对我们样本的分层结果，有早期的证据表明，这是一种优越的整合技术。  </p>
<p>每当一个单元被分割，它对总积分的贡献就被分成两半。新的积分样本被乘以空单元的大小。在分割和取样发生后，从叶子到根的路径被遍历，更新存储在每个节点的积分为其子节点的积分之和。通过保持非根部内部节点的积分，我们能够通过样本的密度来自动缩放规模，以保持一个恒定的度量。  </p>
<p>图3显示了与传统蒙特卡罗技术相比，二维积分的收敛情况。积分估计值与样本数的关系图。上面显示的是传统的估计，下面显示的是分层积分。我们正在对平面上的一个连接区域进行简单的阶梯函数积分。<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/fig3.png" alt="图3">   </p>
<h3 id="自适应分层整合"><a href="#自适应分层整合" class="headerlink" title="自适应分层整合"></a>自适应分层整合</h3><p>这一技术的第四个阐述涉及到除了领域内样本的均匀性之外的其他标准。在这一变化中，我们试图将样本集中在领域的有趣部分，并对积分几乎为常数的那些区域进行稀疏的采样。  </p>
<p>我们寻求树的有趣部分并进行进一步标准完善。如何将这些标准纳入算法中？很容易想到，序列一致采样的子节点选择规则是设置概率阈值的一种方式。在单位区间内选择一个统一的随机数。如果规则说要选择左边或右边的子节点，那么均匀规则会计算出一个阈值是1或0。如果规则说要随机选择，则阈值被设置为0.5。 </p>
<p>现在让我们计算一些阈值 φ1, … ,φk，要考虑到所有这些阈值函数，一个有效的方案是形成它们的凸组合，作为全局阈值φ，由以下公式给出<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/AHI.png" alt="AHI"><br>每个φ为其对应的阈值函数提供一个权重，以便总的策略可以进行调整。  </p>
<p>哪些是有用的阈值函数？ 我们已经找到了一些，但很明显，还有很多有待发现。我们发现有用的阈值函数包括：1）均匀采样阈值；2）完全随机阈值（φ&#x3D;.5）；3）两个子节点的积分之差；4）这个子节点的活动变化历史（可能是积分的方差，或一些加权的时间历史）；5）可以预测到的光照先验函数。  </p>
<p>到目前为止，我们在寻找适应性标准方面的实验还没有取得很大的成功。我们没有使用普适性方法计算最终图像。  </p>
<h3 id="非一致性采样：重要性采样的类似方法"><a href="#非一致性采样：重要性采样的类似方法" class="headerlink" title="非一致性采样：重要性采样的类似方法"></a>非一致性采样：重要性采样的类似方法</h3><p>最后，第五种技术考虑到了重要性采样。与其把一个叶子单元完全分成两半，不如沿着一个代表某种概率密度函数中位数的超平面来划分。 所选择的超平面是由第二种技术中的k-d树的级别所决定的。将概率密度表示为一个综合分布函数，选择中位数超平面是通过快速的折半查找来实现的：为了找到概率密度f(x)的中位数，我们只需搜索F(x)&#x3D;.5的那一点。  </p>
<p>重要性抽样是一种非常重要的降低方差的技术，在解决渲染方程时可以发挥很大的优势。  </p>
<h2 id="对渲染方程的应用"><a href="#对渲染方程的应用" class="headerlink" title="对渲染方程的应用"></a>对渲染方程的应用</h2><p>上面介绍的蒙特卡洛算法都可以应用到渲染算法的解决方案中。例如，序列一致采样被用来对景深模糊的光圈进行取样。自适应分层整合被用来对像素进行子采样。沿着中位数分割的重要性采样被用于选择一个方向来拍摄下一条光线。我们将照明模型存储为一个总和面积表[Crow 1985]给出一个概率分布函数，它可以经过二进制搜索来寻找反射单元中的中值。由于我们搜索的是光照模型的中值超平面，所以域的非线性变换并不特别重要。我们只需将一对输入和输出的半球体投射到切平面上。  </p>
<p>将路径的方法与传统的光线追踪算法进行比较是很有意思的。事实上，将传统的光线追踪转换为这种算法是非常容易的。我们基本上是执行传统的光线追踪算法，但我们不是在每个表面上进行光线树的分支，而是只遵循其中的一个分支，在树上给出一个路径。我们总是向已知的光源投射，当然，这些光源可能是扩展光源。因此，光线追踪与积分方程法的示意图是这样的。<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/appli.png" alt="appli">  </p>
<p>现在这张图指出了一个重要的现象。由于表面的无源性，众所周知，第一次散射射线和光源射线是最重要的，因为它们对像素积分变化幅度的贡献最大。 第二次和更高一次的光线散射射线对积分变化幅度的贡献要小得多。但是传统的光线追踪法恰恰把大部分的工作花在了那些对图像的变化幅度贡献最小的光线上，它计算了太多的高传输次数的光线。 路径积分方程法避免了这种缺点。因为路径是一棵分枝率为1的树，有多少条不同的第一次散射射线，就有多少条高次散射射线。这对于减少运动模糊、景深和分布式光线追踪中的其他效果的差异非常重要。  </p>
<p>这张图还指出了传统随机光线追踪的另一种算法。与其计算一棵分支树，不如计算一条以概率方式选择射线的路径。<br>对于有很多反射和折射的场景来说，这大大减少了一个给定像素所要计算的光线物体交叉点的数量，并以极少的编程工作完成了光线追踪的显著加速。然而，对于这种新的快速光线追踪形式——路径追踪，我们发现，保持对每个像素的反射、折射和阴影射线类型的正确比例是非常重要的。与其完全随机地选择射线方向，不如遵守以下两种规则。 第一种方法，跟踪每种射线类型的分布数量。通过改变每种类型的概率，确保射线类型的样本分布与所需的分布密切相关，这样就能更确定样本分布是匹配的。这就是我们实际实施的方法。 第二种方法是让射线被随机选择，但按期望分布与所产生的加权样本分布的比例来衡量每个射线类型的贡献。  </p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>图5和图6显示了积分方程技术的结果图像。在每个表面元素被击中时，从一个由高光、漫反射和透射系数决定的分布中计算出一个随机变量。这个随机变量被用来选择从表面元素射出的一条射线。在每个光源上选择一个随机点，作为一条光线的目标。实际使用的减少方差的方法是选择新射线的漫射方向、镜面方向和折射方向的多维顺序采样。多维序列采样也被用来选择光源和成像孔径上的点。分层积分被用来对像素值进行抗锯齿处理。 这两幅图像都没有使用自适应或非一致性采样。很明显，重要性采样将大大改善图像的价值。虽然重要性采样的理论很简单，也很直截了当，但还没有做到。此外，跟踪每个像素的变化量和收集顺序已被证明是一个有重要意义的加速。然而，我们的项目对这些图像没有这样做，我们计算了一个每个像素的恒定的40条路径。  </p>
<p><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/fig5.png" alt="fig5"><br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/fig6.png" alt="fig6">  </p>
<p>图5显示了一个通过两种技术渲染的模型。左边是通过标准的光线追踪技术渲染的模型（尽管环境系数被设置为0，以及上面提到的单一分支比率的加速）。右边的图片显示的是通过积分方程渲染的结果。两幅图像都是256×256像素，每个像素有固定的40条路径。这些图像是在IBM-4341上计算的。第一幅图像花了401分钟的CPU时间，第二幅图像花了533分钟。请注意，球体在阴影中的区域吸收了光线追踪图片中缺少的环境照明。另外，光线从球体的底部反弹，照亮了底层平面。  </p>
<p>在图6中，我们展示了一幅图像，说明了积分方程技术的力量。场景中的所有物体都是中性的灰色，除了绿色的玻璃球和基础多边形（略带红色）。灰色物体上的任何颜色在光线追踪图像中都会消失。 请注意，绿色的玻璃球在场景中的物体上投下了微小的光线。在右上方的扁球形的底部，有颜色从浅色的基础多边形中渗出。为了便于比较的目的，这个场景中的不透明表面是符合兰伯特模型的，但对可以使用的光照模型没有限制。图6是一张512乘512像素的图像，每个像素有40条路径。它是在IBM 3081上计算的，消耗了1221分钟的CPU时间。Al Barr提供了这个图像的模型。</p>
<h3 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h3><p>感谢Al Barr、Tim Kay、RobCook、Jim Blinn以及CS286计算机图形研讨会的成员，感谢他们的技术讨论。我感谢IBM、洛杉矶科学中心的Juan Rivero和Yorktown Heights Research的Alan Norton向加州理工学院捐赠了大量的主机运行时长。我还要感谢审稿人提出的许多周到的意见。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://quercussprings.github.io/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/" data-id="cm5kj5st3000m7ov99c8b4rlf" data-title="《The Rendering Equation》简译" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/James-T-Kajiya/" rel="tag">James T. Kajiya</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%8F%E5%85%B8%E8%AE%BA%E6%96%87/" rel="tag">经典论文</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag">计算机图形学</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91%E4%B8%8E%E7%AC%94%E8%AE%B0/">文章翻译与笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/James-T-Kajiya/" rel="tag">James T. Kajiya</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag">基础知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" rel="tag">归并排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" rel="tag">快速排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%85%B8%E8%AE%BA%E6%96%87/" rel="tag">经典论文</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag">计算机图形学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/James-T-Kajiya/" style="font-size: 10px;">James T. Kajiya</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 10px;">基础知识</a> <a href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">归并排序</a> <a href="/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">快速排序</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/tags/%E6%A0%88/" style="font-size: 10px;">栈</a> <a href="/tags/%E7%BB%8F%E5%85%B8%E8%AE%BA%E6%96%87/" style="font-size: 10px;">经典论文</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 10px;">翻译</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" style="font-size: 10px;">计算机图形学</a> <a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">链表</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/02/20/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/">leetbook算法笔记（三）排序专题</a>
          </li>
        
          <li>
            <a href="/2024/02/18/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E9%93%BE%E8%A1%A8%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/">leetbook算法笔记（二）链表、队列和栈</a>
          </li>
        
          <li>
            <a href="/2024/02/15/leetbook%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%20/">leetbook算法笔记（二）链表、队列和栈</a>
          </li>
        
          <li>
            <a href="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/">《The Rendering Equation》简译</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Quercus<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>