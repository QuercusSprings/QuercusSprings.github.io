<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Quercus的技术记录</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Quercus的技术记录">
<meta property="og:url" content="https://quercussprings.github.io/index.html">
<meta property="og:site_name" content="Quercus的技术记录">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Quercus">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Quercus的技术记录" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Quercus的技术记录</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://quercussprings.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/26/hello-world/" class="article-date">
  <time class="dt-published" datetime="2022-06-26T09:03:15.653Z" itemprop="datePublished">2022-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/26/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://quercussprings.github.io/2022/06/26/hello-world/" data-id="cl4v6v3lc00006sv9gn8q3yu7" data-title="Hello World" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-渲染方程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-12-18T15:21:15.000Z" itemprop="datePublished">2021-12-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91%E4%B8%8E%E7%AC%94%E8%AE%B0/">文章翻译与笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/">渲染方程简译</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h1><h5 id="SIGGRAPH-1986-1986-4"><a href="#SIGGRAPH-1986-1986-4" class="headerlink" title="SIGGRAPH 1986(1986.4)"></a>SIGGRAPH 1986(1986.4)</h5><h5 id="James-T-Kajiya"><a href="#James-T-Kajiya" class="headerlink" title="James T. Kajiya"></a>James T. Kajiya</h5><h5 id="加州理工学院"><a href="#加州理工学院" class="headerlink" title="加州理工学院"></a>加州理工学院</h5><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>我们提出了一个集已知的渲染算法之大成的积分方程。在讨论用蒙特卡洛法解决此问题时，我们也提出了一种新的样本方差减少方法，其称为“分层采样法”，并给出了有关此方法的详细阐述。由此产生的渲染算法扩展了可以有效模拟的光学现象的范围。</p>
<h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>计算机图形学，光栅化，光线追踪，辐射度量学，蒙特卡洛法，分布式光线追踪，方差消减。</p>
<h2 id="渲染方程-1"><a href="#渲染方程-1" class="headerlink" title="渲染方程"></a>渲染方程</h2><p>我们提出的技术涵盖了各种各样的渲染算法，并提供了一个统一的研究背景，以便于可以将之前各式的算法视作这一方程的各种近似。一旦意识到所有的渲染方法都试图模拟相同的物理现象，即光在各种表面散射（译注：此处及下文的散射是广义的，反射和折射都是弹性散射。不过未经专门说明，将这些”散射”理解为漫反射是更简单的方法）的现象，就不会对形形色色的渲染方法能归于一式感到惊讶了。  </p>
<p>对我们所提的渲染方程，其背后的想法已不新鲜。对这个方程所模拟的现象的描述，在辐射传导领域中已经研究了数年[Siegel , Howell 1981]。然而，我们提出的这个很适合于计算机图形学的方程形式，在以前却未出现过。  </p>
<p>渲染方程为<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B.png" alt="渲染方程"><br>其中：I(x, x’)  约束了从x’到x点的辐射强度<br>g(x, x’)  是几何分量<br>e(x, x’)  约束了从x’到x点的自发光强度<br>ρ(x, x’,x’’)  约束了一定表面上散射光的强度</p>
<p>这个方程非常符合辐射度量学方程的精神，只是简洁地平衡了从单一表面的一个点到另一个点的能量。该方程指出，从一个点到另一个点的光的传输强度只是自发光和从所有其他表面点散射到该点的总的光强度之和。方程(1)与辐射度量学方程的不同之处在于，没有对相关表面的反射特性作出假设。  </p>
<p>对方程中每一个量，我们都暂称为“非闭合的多重传输量”。我们将在第二节逐个给出定义并将其与·辐射度量学联系起来。 </p>
<p>该积分的积分域是在所有几何表面上，因此点x、x’、x’’的范围也是在此域中。不仅如此，还有定义了背景表面S0，其是一个足够大的半球，能够作为整个模型完全的包围圈。需要指出的是，该包围半球的正半球涵盖光线可能的所有反射域，负半球涵盖了光线可能的所有传输域。</p>
<p>作为麦克斯韦电磁方程的一个近似模拟，(1)并没有模拟所有有趣的光学现象。(1)并不试图对所有光学现象进行建模，它基本上是一个几何光学近似。我们只建立了时间平均传输强度的模型，因此在这个方程中没有考虑到辐射相位————即排除了对衍射的任何处理。我们还假设了不同介质表面之间是均匀的折射率，并且本身不参与散射光。后两种情况可以通过公式(1)的成对归纳来处理，在第一种情况下，只需让g(x, x’)考虑到具有非均质折射率的介质以处理光程。对于参与传播的介<br>质，需要一个整数微分方程。其拓展延伸也是众所周知的，见[Chandraseka.r 1950]，以及用于计算机图形应用的[Kajiya and von Herzen 1984]。处理不同介质光程的合理方式，哈密顿-雅可比方程[Goldstein 1950]，至少在一个世纪前就有了，对参与介质以及相位和衍射的处理可以被其处理。关于这些与各种物理现象有关的光学拓展方法，见[Feynman and Hibbs 1965]。最后，公式(1)中确实没有提到波长或偏振的相关性质。而考虑波长和偏振却是理所应当的。  </p>
<h2 id="对传输量的论述"><a href="#对传输量的论述" class="headerlink" title="对传输量的论述"></a>对传输量的论述</h2><p>在此我们讨论方程（1）的每个物理量和数学项。<br>这个方程描述了一个简化模型的光线传输过程。我们将把I(x,x’)命名为从x’到x的非闭合的两点辐射强度，或者更简洁地称其为辐射强度。辐射强度I( x, x’) 是单位时间单位区域dx’向dx的辐射能量。<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/2.png" alt="辐射强度"><br>I的单位是瓦特每球面度每平方米。  </p>
<p>数学量g(x, x’) 是一个几何项，这个项对表面点被其他表面点遮挡的情况进行标记。如果在场景中，x’和x实际上不是相互可见的，那么这个几何项就是0。另一方面，如果它们彼此可见，那么这个项就是1&#x2F;r2，其中r是x’到x的距离。注意到，一个闭合的完全透明的表面可以使g(x, x’)等于0。因为事实上，透明的表面截留了辐射的反射能量，并将其重新折射到另一边。  </p>
<p>自发光项e(x, x’)，其测量的是发出于x’点到达x点的能量。我们称其为“非闭合的自发光转移量”。它给定了单位时间单位面积的光源到达目标单位面积的能量，亦即：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/3.png" alt="自发光项e"><br>其单位为瓦特每平方米。 </p>
<p>最后，辐射率ρ(x, x’, x”)是由x’处的表面辐射出的能量强度，从x”方向的入射光线开始，到x方向的出射光线结束。我们将称它为“从x “到x’处的非闭合的辐射率”。所以到达x的能量是：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/4.png" alt="辐射率"><br>其单位为瓦特每球面度每平方米。  </p>
<p>现在我们把传输量与更常规的辐射度量学联系起来。我们将通过在给定的数学几何模型中，论述能量传输模型中的每个量来实现这一点。 </p>
<p>通用辐射度量模型中的辐射强度（译注：光学上称发光强度）定义为每单位时间每单位投射面积的能量，即：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/5.png" alt="辐射能量_度量学">  </p>
<p>由几何模型可知：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/6.png" alt="立体角推导"><br>其中：向量n是表面dx的法向量<br>向量n’是表面dx’的法向量<br>向量t’是表面dx’的切向量<br>标量r 是x’ 到x 的距离  </p>
<p>一个表面项dx所对应的立体角是半径为r的球体被dx的球面投影面积dxp所占据的面积。即：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/7.png" alt="立体角公式">  </p>
<p>那么，将公式(7)带入到公式(5)能够得到：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/8.png" alt="辐射能量_立体角">   </p>
<p>公式(2)和公式(5)的比较能给出我们定义的辐射强度这一传输量和通用辐射度量学的关系：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/9.png" alt="辐射强度_度量学">  </p>
<p>自发光项与通用辐射度量学的关系也是这样得到的。假设有非闭合的表面，从dx’到dx的自发光分量，由公式(3)定义。通过如上引入立体角的流程，我们可以得到：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/10.png" alt="自发光_度量学">  </p>
<p>最后，我们将传输量中的反射率与通用辐射度量学中的双向反射函数ρ(θ’, φ’, ψ’, σ’)联系起来，从定义来看：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/11.png" alt="BRF">  </p>
<p>我们除了能得到方程(6)和(7)外，还可得到以下内容：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/12.png" alt="BRF_几何量"><br>其中：<br>向量n’’ 是表面dx’’的法线向量<br>标量r’’ 是x’’到x’的距离<br>dω’’为基于dx’’的立体角<br>结合公式(2)、(8)、(9)、(11)和(12)，我们可以得到非闭合的考虑三点的双向反射函数定义：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/13.png" alt="BRF_定义">  </p>
<h2 id="诸近似求解法"><a href="#诸近似求解法" class="headerlink" title="诸近似求解法"></a>诸近似求解法</h2><p>在本节中，我们将回顾渲染方程的近似解法。这些近似解法表明，各种渲染算法都可以在这个渲染方程提供的统一背景下进行研究。在讨论的过程中，读者可能会想到许多其他未曾尝试过的近似解法。我们鼓励研究者在这个领域开展更多的工作。这个领域在很大程度上还未被探索，因为目前的大部分努力只集中在下面要介绍的诸解决方法上。  </p>
<h3 id="诺伊曼级数"><a href="#诺伊曼级数" class="headerlink" title="诺伊曼级数"></a>诺伊曼级数</h3><p>解决像公式(1)这样的积分方程的一种方法来自一个众所周知的形式化操作，见[Courant and Hilbert 1953]。我们可将其改写为如下形式:<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/Neumann_a.png" alt="诺伊曼_a"><br>其中M是由公式(l)中的积分所给出的线性算子。现在，我们可把这个方程改写为：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/Neumann_b.png" alt="诺伊曼_b"><br>其中1是单位算子，由此我们可以通过以下方式形式地反转该等式：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/Neumann_c.png" alt="诺伊曼_c"><br>该无限级数收敛的一个条件是算子M的谱半径小于1。(在我们讨论的情况下，这一点是可以满足的）。对诺伊曼级数展开的物理解释同样吸引我们。它描述了辐射传输模型的辐射强度实质上是直接光照项、一次散射项、二次散射项、与以此类推的多次散射项之和。  </p>
<h3 id="犹他近似"><a href="#犹他近似" class="headerlink" title="犹他近似"></a>犹他近似</h3><p>由于缺乏更好的说法，我们将直接把渲染着色表面的经典方法称为犹他近似法（译注：实际上这是后世所称Blinn-Phong经验模型的数学物理依据）。在这种近似法中我们直接用两项之和来近似辐射强度I：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/utah.png" alt="犹他近似"><br>能看到，犹他近似法忽略除了一次散射外所有的散射，到目前为止，几何项成为最难计算的项。Utah近似法只对最终散射进入眼睛的g项进行计算。当然，这就成为由犹他大学的许多早期研究人员研究的经典的隐藏面问题。请注意，在第二项中，算子M不在ge上操作，而是在直接影响e0。因此，这个近似值忽略了自发光的可见性，亦即忽略了阴影。e0项意味着只考虑单一点光源。没有考虑扩展的其他照明表面。这种简化将算子M简化为对点光源的一个有限规模的求和，而不是对整个投射光域x’’的积分。  </p>
<p>从那时起，出现了许多拓展算法，最引人注目的是阴影处理算法和扩展光源种类的工作。  </p>
<h3 id="光线追踪算法"><a href="#光线追踪算法" class="headerlink" title="光线追踪算法"></a>光线追踪算法</h3><p>Whitted[1980]，提出了一个不同于前的近似方法：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/whitted.png" alt="光线追踪"><br>在这一著名的近似中， M0是一个散射模型，它是两个delta函数和一余弦项的总和。这两个delta函数代表了他照明模型中的反射和折射，余弦项代表漫反射成分。应注意，他考虑到了ge0亦即阴影，但仍然是处于点光源下的情况。Whitted的环境光项直接来自e项。 同样的，算子M是一个有限规模求和。  </p>
<h3 id="随机光线追踪算法"><a href="#随机光线追踪算法" class="headerlink" title="随机光线追踪算法"></a>随机光线追踪算法</h3><p>1984年，Cook[Cook et al 1984]，引入了随机光线追踪算法。这种近似方法是了具有三部分的Whitted模型的扩展，从而产生了一个更精确的散射模型。这一扩展使得在计算算子M时，对积分的估值变得必要。在这个模型中，M是由反射和折射delta函数的分布估值来近似表示的。使之成为可能的创新是使用蒙特卡洛法来进行积分数值估计。众所周知，估计积分数值的能力广泛地扩展了可被分析的光学现象其范围。<br>然而，对于随机光线追踪来说，对环境光项的适当处理仍然难以实现。  </p>
<h3 id="辐射度方法"><a href="#辐射度方法" class="headerlink" title="辐射度方法"></a>辐射度方法</h3><p>1984年，Cohen md Greenburg 在计算机图形学领域引入了辐射度方法，这是一项重要的新型渲染技术。它可以处理理想漫反射表面的能量平衡。也就是说平滑表面遵守如下的双向反射函数。<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/14.png" alt="辐射度方法"><br>定义在表面dx’的辐射度B(x’) 是整个可见半球的辐射通量。它是单位时间内单位（未经投影的）区域的能量，单位瓦特每平方米。定义是<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/15.png" alt="辐射度"><br>由此，为了计算半球域上的所有辐射量，我们可以简单地对场景中的所有表面进行积分。故，从公式(1)和(15)中我们可以得到：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/16.png" alt="辐射度_联系几何量"><br>如果x和x’之间存在遮挡，那么自发光项的贡献为零。否则，其贡献为：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/17.png" alt="辐射度_联系球面度"><br>其中e0是基于表面元素dx’的半球形辐照度。<br>同样，对于反射项，若表面被遮挡，则反射项对辐射度的贡献也是零。未被遮挡时，我们会得到：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/18.png" alt="辐射度_联系球面度"><br>其中H是单位时间内单位面积的半球域中入射的能量。 在这个推导中，我们转换了积分的顺序，并使用了(13)、(12)和(14)的特征。现在使用方程(17)和(18)，再基于(16)，我们能看到，渲染方程变为：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/19.png" alt="辐射度_结果"><br>这就是Goral等人推导出的公式(4) [1984]  </p>
<p>计算积分的辐射强度H对于计算辐射率中最终的Fij矩阵至关重要。这需要进行可见度计算，这可能是相当耗时的。由于矩阵方程是通过一些松弛迭代步骤来解决的，它基本上等同于对诺伊曼级数的前几项进行求和，即自发光量传播四次左右的散射量。使用松弛法需要计算全部的矩阵。松弛法还可以提供场景中所有表面的所有辐射强度。虽然在某些情况下，这可能是一个优势，但使用下面概述的蒙特卡洛方法可能更为先进。  </p>
<h2 id="马尔可夫链求解积分方程"><a href="#马尔可夫链求解积分方程" class="headerlink" title="马尔可夫链求解积分方程"></a>马尔可夫链求解积分方程</h2><p>马尔科夫链的使用可能是解决积分方程的最流行的数值方法。 它被广泛应用于队列论和中子迁移等领域。事实上，在辐射传导中使用马尔科夫链蒙特卡洛法已经有一段时间了[Siegel, Howell 1981]。在热传导方法中，一个特定波长的辐射量从某个特定表面中发射、反射和吸收。计算每个表面吸收的辐射量，依据于几何因素的估算，而精确的计算将是一个难以解决的问题。这类似于从光源到眼睛的光线追踪。但我们不采用这些方法，而是选择更直接地解决公式(1)，回到von Neumann 和 Ulam首次提出的早期蒙特卡洛方法[Rubenstein 1981]  </p>
<h3 id="有限空间求解"><a href="#有限空间求解" class="headerlink" title="有限空间求解"></a>有限空间求解</h3><p>作为介绍，我们首先在一个有限元的背景下介绍这个方法。这简化了符号，并使所涉及的基本思想变得明显。我们再一次注意到，这个例子中的方法可能比目前流行的辐射度松弛方案有很多优势：只需要计算可见点的辐射度，而整个辐射度矩阵的计算可以换成非常有限的一组选定矩阵元素。  </p>
<p>假设我们希望解决矢量方程：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/MCMC_0.png" alt="MCMC_0"><br>其中x和a是n维向量，x是未知量，且M&#x3D;(m_ij)是n×n的矩阵。<br>现在从诺伊曼拓展中我们可以看到，对于矩阵M来说，特征值处于单位圆范围内的。x的解法由下公式给出：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/MCMC_1.png" alt="MCMC_1"><br>该方法通过矩阵乘法的路径平均对积分求积。亦即它依靠逐矩阵行和矩阵列的路径，构成一个迭代的矩阵乘积。对于路径中的每个点我们得到一系列行或列，可以用一个从1到n的整数来索引。  </p>
<p>构建一个概率空间O，其中每个样本ω是在每个离散时间内访问n个点之一的路径，即 ω &#x3D;（n0，n1，…，n），对其中的每个n，都是1至n的正整数。对于路径ω的度量量k&#x3D;l(ω)是有限的，但在其他方面是任意且一致的，并对应于k级矩阵幂。每条路径都被分配了一个概率p(ω)<br>如果我们想计算x的一个坐标值，记作x1，其值计算如下：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/MCMC_2.png" alt="MCMC_2"><br>对于所有路径的平均ω∈Ω，简单地取期望就可以得到这个量预期的量。  </p>
<p>路径的概率空间更加容易用马尔科夫链来构建。一个（静态的）离散马尔可夫链包括一组状态X，以及从一个状态x’∈X 到另一个状态x∈X的过渡概率p(x, x’)，还有一个初始状态的概率密度p(x)。一些状态的子集可以被指定为吸收态，即不允许从吸收态中转换出来。   </p>
<p>马尔可夫链产生的路径的概率是初始状态和所有过渡概率的积，直到达到一个吸收状态为止。因此，对于一条路径：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/MCMC_3.png" alt="MCMC_2"><br>有n-阶马尔可夫链路径概率：<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/MCMC_4.png" alt="MCMC_2"><br>在有限维度的情况下，我们让马尔科夫链的状态集作为向量或矩阵的索引集，即X &#x3D; {1, … , n}。理应注意，尽管我们在选择过渡概率时是宽容的，但与非零状态对应的过渡概率必须是非负的。我们对积分解的估值极限完全独立于路径的概率分布，但收敛到极限的速度在很大程度上取决于选择过渡概率的方式。第5节给出了一套选择过渡概率的新方法。</p>
<h3 id="无限空间求解"><a href="#无限空间求解" class="headerlink" title="无限空间求解"></a>无限空间求解</h3><p>将马尔科夫链蒙特卡洛方法扩展到无限维度空间是很简单的。对于眼前的积分方程，我们注意到它是第二类弗雷德霍姆积分方程的变体。表面在反射和透射方面的无源被动性保证了诺伊曼级数的收敛。我们只需用表面上的点x的集合来代替状态集，计算这些点的流程程序如下：  </p>
<ol>
<li>在场景中选择一个通过视口可见的点x’到视口上选定的像素x。  </li>
<li>加上辐射强度。  </li>
<li>对于马尔可夫链路径中的度量<br>3.1 选择点x’’并计算几何因子g(x,x’’)。<br>3.2 计算反射率ρ(x, x’, x’’) 并乘以e(x’, x”)。<br>3.3 将这一结果加入到像素辐射强度中。</li>
</ol>
<p>应知，计算辐照度和散射系数仅仅是计算纹理贴图和光照模型的问题。计算几何因子实际上就是光线追踪的光线对象求交。还要注意的是，通过以选定的角度射出射线并找到最近的交点来选择马尔可夫路径上的下一个点x’’，我们实际上是在进行有效的重要性采样优化。也就是说，我们不需要计算另两个闭塞点x’, x’’的积分，因为我们知道这个积分将是零。这与辐射度算法中的松弛过程相反，后者总是从所有表面获取能量贡献。  </p>
<h2 id="分层采样"><a href="#分层采样" class="headerlink" title="分层采样"></a>分层采样</h2><p>我们现在提出了一些新的减少方差的技术，以解决渲染方程的问题。然而，我们必须指出，这里所指出的技术能够应用的范围要广得多。一般来说，它们对积分特别困难的各种蒙特卡罗积分问题都有帮助。在这种情况下，比以前已知的方法所多增加的开销都变得可以忽略不计。我们提出了五种方法，它们越来越多地利用了有价值的被积样本的优点。下面概述的所有技术都受到分层抽样的启发。  </p>
<h3 id="序列一致采样"><a href="#序列一致采样" class="headerlink" title="序列一致采样"></a>序列一致采样</h3><p>第一种采样技术源于一种常见的顺序抽样策略。通常情况下，积<br>分的样本被反复收集，直到积分估计的样本方差低于一个固定的<br>阈值。这种策略在[Lee, Redner and Uselton 1985]中被证明是有优势的，他们在图像的感兴趣部分收集到了许多样本，同时在不感兴趣的部分收集到的样本则很少。  </p>
<p>不幸的是，这种顺序策略与分层采样并不兼容。在分层采样技术中，感兴趣的领域被划分为子单元。Lee使用每像素8个单元的固定细分，并在每个单元内随机抽取样本。理想情况下。当每个均匀划分单元收集一个样本时，可以获得更好的收敛性。这就是所谓的抖动采样方法。通常我们认为单元的中心形成一个网格。顺序取样<br>和抖动取样之间的不相容性是由于在精确知道将采集多少个样本<br>之前，不可能对采样域进行均匀的细分。  </p>
<p>顺序均匀取样是通过保持一棵不同大小的单元树来实现的。不同大小的单元。每次取样时，首先选择一个单元，然后再分成若干单元。原始单元的旧样本必须在一个新的子单元中。新的样本则被选在相反的单元中。一个简单的图示将说明这一技术。<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/HS_0.png" alt="SUS">   </p>
<p>为了投射一个新的样本点，我们遍历树，直到遇到一个未访问的叶子单元。然后我们把叶子单元分成两半，把样本投到空的那一半单元。  </p>
<ol>
<li>如果该节点是一个内部节点<br>1.1 选择一个子节点<br>1.2 完善所选择的子节点<br>1.3 返回  </li>
<li>否则，分割叶子节点  </li>
<li>将旧样本传播到包含它的子叶中。  </li>
<li>在剩余的空子叶上投下一个新样本</li>
</ol>
<p>我们怎样才能保证进行尽可能均匀的细分？一种方法是以广度优先的顺序遍历采样树。在分割更深的节点之前，在每一级都分割一个叶子节点。这种策略产生了高度有序的样本分布，基本上是在区间内扫描。一个更好的方法是以随机顺序广度优先分割节点。以下流程体现了这种规划策略。  </p>
<ol>
<li>如果其中一个是叶子，就选择它。  </li>
<li>如果层(左)&lt;层(右)且左边是平衡的，选择左边的节点。  </li>
<li>如果层(右)&lt;层(左)且右是平衡的，选择右边的节点。  </li>
<li>否则就随机选择。</li>
</ol>
<p>请注意，这个策略实际上是在整个区间内进行随机搜索，而不是<br>集中在任何特定区域。  </p>
<h3 id="多重维度情况"><a href="#多重维度情况" class="headerlink" title="多重维度情况"></a>多重维度情况</h3><p>上述算法很容易扩展到更高的维度，只需使用一种由Bentley[Bentley 1979]提出的被称为K-D树的数据结构即可。在这种数据结构中，域被一个垂直于连续共轴的超平面连续地分成两半。因此，对于一个单位区域，k-d树首先沿着垂直线进行细分，然后在下一级沿着水平线进行细分。上述统一的子节点选择规则确保了统一的细分，不需要任何修改。对路径空间的推广是直接的。  </p>
<h3 id="分层整合"><a href="#分层整合" class="headerlink" title="分层整合"></a>分层整合</h3><p>上述技术的第三个版本利用了以下事实。每个样本的单元都样本本身的记录。在这种情况下我们就可以计算出一个黎曼和，用单元的大小和样本的值作为积分。Yakowitz [Yakowit et al 1978]提出了这种方法的一个变体（使用样本本身作为边界点，没有分层）。他发现在一维中的方差为O(n^-4)，而在二维中的方差为O(n^-2)。这大大优于O(n^-1)的简单蒙特卡洛法。我们的技术分析仍在进行中并将出现在一篇配套的论文中。但依据对我们样本的分层结果，有早期的证据表明，这是一种优越的整合技术。  </p>
<p>每当一个单元被分割，它对总积分的贡献就被分成两半。新的积分样本被乘以空单元的大小。在分割和取样发生后，从叶子到根的路径被遍历，更新存储在每个节点的积分为其子节点的积分之和。通过保持非根部内部节点的积分，我们能够通过样本的密度来自动缩放规模，以保持一个恒定的度量。  </p>
<p>图3显示了与传统蒙特卡罗技术相比，二维积分的收敛情况。积分估计值与样本数的关系图。上面显示的是传统的估计，下面显示的是分层积分。我们正在对平面上的一个连接区域进行简单的阶梯函数积分。<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/fig3.png" alt="图3">   </p>
<h3 id="自适应分层整合"><a href="#自适应分层整合" class="headerlink" title="自适应分层整合"></a>自适应分层整合</h3><p>这一技术的第四个阐述涉及到除了领域内样本的均匀性之外的其他标准。在这一变化中，我们试图将样本集中在领域的有趣部分，并对积分几乎为常数的那些区域进行稀疏的采样。  </p>
<p>我们寻求树的有趣部分并进行进一步标准完善。如何将这些标准纳入算法中？很容易想到，序列一致采样的子节点选择规则是设置概率阈值的一种方式。在单位区间内选择一个统一的随机数。如果规则说要选择左边或右边的子节点，那么均匀规则会计算出一个阈值是1或0。如果规则说要随机选择，则阈值被设置为0.5。 </p>
<p>现在让我们计算一些阈值 φ1, … ,φk，要考虑到所有这些阈值函数，一个有效的方案是形成它们的凸组合，作为全局阈值φ，由以下公式给出<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/AHI.png" alt="AHI"><br>每个φ为其对应的阈值函数提供一个权重，以便总的策略可以进行调整。  </p>
<p>哪些是有用的阈值函数？ 我们已经找到了一些，但很明显，还有很多有待发现。我们发现有用的阈值函数包括：1）均匀采样阈值；2）完全随机阈值（φ&#x3D;.5）；3）两个子节点的积分之差；4）这个子节点的活动变化历史（可能是积分的方差，或一些加权的时间历史）；5）可以预测到的光照先验函数。  </p>
<p>到目前为止，我们在寻找适应性标准方面的实验还没有取得很大的成功。我们没有使用普适性方法计算最终图像。  </p>
<h3 id="非一致性采样：重要性采样的类似方法"><a href="#非一致性采样：重要性采样的类似方法" class="headerlink" title="非一致性采样：重要性采样的类似方法"></a>非一致性采样：重要性采样的类似方法</h3><p>最后，第五种技术考虑到了重要性采样。与其把一个叶子单元完全分成两半，不如沿着一个代表某种概率密度函数中位数的超平面来划分。 所选择的超平面是由第二种技术中的k-d树的级别所决定的。将概率密度表示为一个综合分布函数，选择中位数超平面是通过快速的折半查找来实现的：为了找到概率密度f(x)的中位数，我们只需搜索F(x)&#x3D;.5的那一点。  </p>
<p>重要性抽样是一种非常重要的降低方差的技术，在解决渲染方程时可以发挥很大的优势。  </p>
<h2 id="对渲染方程的应用"><a href="#对渲染方程的应用" class="headerlink" title="对渲染方程的应用"></a>对渲染方程的应用</h2><p>上面介绍的蒙特卡洛算法都可以应用到渲染算法的解决方案中。例如，序列一致采样被用来对景深模糊的光圈进行取样。自适应分层整合被用来对像素进行子采样。沿着中位数分割的重要性采样被用于选择一个方向来拍摄下一条光线。我们将照明模型存储为一个总和面积表[Crow 1985]给出一个概率分布函数，它可以经过二进制搜索来寻找反射单元中的中值。由于我们搜索的是光照模型的中值超平面，所以域的非线性变换并不特别重要。我们只需将一对输入和输出的半球体投射到切平面上。  </p>
<p>将路径的方法与传统的光线追踪算法进行比较是很有意思的。事实上，将传统的光线追踪转换为这种算法是非常容易的。我们基本上是执行传统的光线追踪算法，但我们不是在每个表面上进行光线树的分支，而是只遵循其中的一个分支，在树上给出一个路径。我们总是向已知的光源投射，当然，这些光源可能是扩展光源。因此，光线追踪与积分方程法的示意图是这样的。<br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/appli.png" alt="appli">  </p>
<p>现在这张图指出了一个重要的现象。由于表面的无源性，众所周知，第一次散射射线和光源射线是最重要的，因为它们对像素积分变化幅度的贡献最大。 第二次和更高一次的光线散射射线对积分变化幅度的贡献要小得多。但是传统的光线追踪法恰恰把大部分的工作花在了那些对图像的变化幅度贡献最小的光线上，它计算了太多的高传输次数的光线。 路径积分方程法避免了这种缺点。因为路径是一棵分枝率为1的树，有多少条不同的第一次散射射线，就有多少条高次散射射线。这对于减少运动模糊、景深和分布式光线追踪中的其他效果的差异非常重要。  </p>
<p>这张图还指出了传统随机光线追踪的另一种算法。与其计算一棵分支树，不如计算一条以概率方式选择射线的路径。<br>对于有很多反射和折射的场景来说，这大大减少了一个给定像素所要计算的光线物体交叉点的数量，并以极少的编程工作完成了光线追踪的显著加速。然而，对于这种新的快速光线追踪形式——路径追踪，我们发现，保持对每个像素的反射、折射和阴影射线类型的正确比例是非常重要的。与其完全随机地选择射线方向，不如遵守以下两种规则。 第一种方法，跟踪每种射线类型的分布数量。通过改变每种类型的概率，确保射线类型的样本分布与所需的分布密切相关，这样就能更确定样本分布是匹配的。这就是我们实际实施的方法。 第二种方法是让射线被随机选择，但按期望分布与所产生的加权样本分布的比例来衡量每个射线类型的贡献。  </p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>图5和图6显示了积分方程技术的结果图像。在每个表面元素被击中时，从一个由高光、漫反射和透射系数决定的分布中计算出一个随机变量。这个随机变量被用来选择从表面元素射出的一条射线。在每个光源上选择一个随机点，作为一条光线的目标。实际使用的减少方差的方法是选择新射线的漫射方向、镜面方向和折射方向的多维顺序采样。多维序列采样也被用来选择光源和成像孔径上的点。分层积分被用来对像素值进行抗锯齿处理。 这两幅图像都没有使用自适应或非一致性采样。很明显，重要性采样将大大改善图像的价值。虽然重要性采样的理论很简单，也很直截了当，但还没有做到。此外，跟踪每个像素的变化量和收集顺序已被证明是一个有重要意义的加速。然而，我们的项目对这些图像没有这样做，我们计算了一个每个像素的恒定的40条路径。  </p>
<p><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/fig5.png" alt="fig5"><br><img src="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/fig6.png" alt="fig6">  </p>
<p>图5显示了一个通过两种技术渲染的模型。左边是通过标准的光线追踪技术渲染的模型（尽管环境系数被设置为0，以及上面提到的单一分支比率的加速）。右边的图片显示的是通过积分方程渲染的结果。两幅图像都是256×256像素，每个像素有固定的40条路径。这些图像是在IBM-4341上计算的。第一幅图像花了401分钟的CPU时间，第二幅图像花了533分钟。请注意，球体在阴影中的区域吸收了光线追踪图片中缺少的环境照明。另外，光线从球体的底部反弹，照亮了底层平面。  </p>
<p>在图6中，我们展示了一幅图像，说明了积分方程技术的力量。场景中的所有物体都是中性的灰色，除了绿色的玻璃球和基础多边形（略带红色）。灰色物体上的任何颜色在光线追踪图像中都会消失。 请注意，绿色的玻璃球在场景中的物体上投下了微小的光线。在右上方的扁球形的底部，有颜色从浅色的基础多边形中渗出。为了便于比较的目的，这个场景中的不透明表面是符合兰伯特模型的，但对可以使用的光照模型没有限制。图6是一张512乘512像素的图像，每个像素有40条路径。它是在IBM 3081上计算的，消耗了1221分钟的CPU时间。Al Barr提供了这个图像的模型。</p>
<h3 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h3><p>感谢Al Barr、Tim Kay、RobCook、Jim Blinn以及CS286计算机图形研讨会的成员，感谢他们的技术讨论。我感谢IBM、洛杉矶科学中心的Juan Rivero和Yorktown Heights Research的Alan Norton向加州理工学院捐赠了大量的主机运行时长。我还要感谢审稿人提出的许多周到的意见。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://quercussprings.github.io/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/" data-id="cl4v6v3lj00016sv95nbeg4ba" data-title="渲染方程简译" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/James-T-Kajiya/" rel="tag">James T. Kajiya</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%8F%E5%85%B8%E8%AE%BA%E6%96%87/" rel="tag">经典论文</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag">计算机图形学</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91%E4%B8%8E%E7%AC%94%E8%AE%B0/">文章翻译与笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/James-T-Kajiya/" rel="tag">James T. Kajiya</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E5%85%B8%E8%AE%BA%E6%96%87/" rel="tag">经典论文</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag">计算机图形学</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/James-T-Kajiya/" style="font-size: 10px;">James T. Kajiya</a> <a href="/tags/%E7%BB%8F%E5%85%B8%E8%AE%BA%E6%96%87/" style="font-size: 10px;">经典论文</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 10px;">翻译</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/" style="font-size: 10px;">计算机图形学</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/26/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/12/18/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/">渲染方程简译</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Quercus<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>